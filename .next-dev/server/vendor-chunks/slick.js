"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slick";
exports.ids = ["vendor-chunks/slick"];
exports.modules = {

/***/ "(rsc)/./node_modules/slick/finder.js":
/*!**************************************!*\
  !*** ./node_modules/slick/finder.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\nSlick Finder\r\n*/\r\n\r\n// Notable changes from Slick.Finder 1.0.x\r\n\r\n// faster bottom -> up expression matching\r\n// prefers mental sanity over *obsessive compulsive* milliseconds savings\r\n// uses prototypes instead of objects\r\n// tries to use matchesSelector smartly, whenever available\r\n// can populate objects as well as arrays\r\n// lots of stuff is broken or not implemented\r\n\r\nvar parse = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/slick/parser.js\")\r\n\r\n// utilities\r\n\r\nvar index = 0,\r\n    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),\r\n    key = \"uid:\" + counter\r\n\r\nvar uniqueID = function(n, xml){\r\n    if (n === window) return \"window\"\r\n    if (n === document) return \"document\"\r\n    if (n === document.documentElement) return \"html\"\r\n\r\n    if (xml) {\r\n        var uid = n.getAttribute(key)\r\n        if (!uid) {\r\n            uid = (index++).toString(36)\r\n            n.setAttribute(key, uid)\r\n        }\r\n        return uid\r\n    } else {\r\n        return n[key] || (n[key] = (index++).toString(36))\r\n    }\r\n}\r\n\r\nvar uniqueIDXML = function(n) {\r\n    return uniqueID(n, true)\r\n}\r\n\r\nvar isArray = Array.isArray || function(object){\r\n    return Object.prototype.toString.call(object) === \"[object Array]\"\r\n}\r\n\r\n// tests\r\n\r\nvar uniqueIndex = 0;\r\n\r\nvar HAS = {\r\n\r\n    GET_ELEMENT_BY_ID: function(test, id){\r\n        id = \"slick_\" + (uniqueIndex++);\r\n        // checks if the document has getElementById, and it works\r\n        test.innerHTML = '<a id=\"' + id + '\"></a>'\r\n        return !!this.getElementById(id)\r\n    },\r\n\r\n    QUERY_SELECTOR: function(test){\r\n        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child\r\n        test.innerHTML = '_<style>:nth-child(2){}</style>'\r\n\r\n        // checks if the document has querySelectorAll, and it works\r\n        test.innerHTML = '<a class=\"MiX\"></a>'\r\n\r\n        return test.querySelectorAll('.MiX').length === 1\r\n    },\r\n\r\n    EXPANDOS: function(test, id){\r\n        id = \"slick_\" + (uniqueIndex++);\r\n        // checks if the document has elements that support expandos\r\n        test._custom_property_ = id\r\n        return test._custom_property_ === id\r\n    },\r\n\r\n    // TODO: use this ?\r\n\r\n    // CHECKED_QUERY_SELECTOR: function(test){\r\n    //\r\n    //     // checks if the document supports the checked query selector\r\n    //     test.innerHTML = '<select><option selected=\"selected\">a</option></select>'\r\n    //     return test.querySelectorAll(':checked').length === 1\r\n    // },\r\n\r\n    // TODO: use this ?\r\n\r\n    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){\r\n    //\r\n    //     // checks if the document supports the empty attribute query selector\r\n    //     test.innerHTML = '<a class=\"\"></a>'\r\n    //     return test.querySelectorAll('[class*=\"\"]').length === 1\r\n    // },\r\n\r\n    MATCHES_SELECTOR: function(test){\r\n\r\n        test.className = \"MiX\"\r\n\r\n        // checks if the document has matchesSelector, and we can use it.\r\n\r\n        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector\r\n\r\n        // if matchesSelector trows errors on incorrect syntax we can use it\r\n        if (matches) try {\r\n            matches.call(test, ':slick')\r\n        } catch(e){\r\n            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)\r\n            return matches.call(test, \".MiX\") ? matches : false\r\n        }\r\n\r\n        return false\r\n    },\r\n\r\n    GET_ELEMENTS_BY_CLASS_NAME: function(test){\r\n        test.innerHTML = '<a class=\"f\"></a><a class=\"b\"></a>'\r\n        if (test.getElementsByClassName('b').length !== 1) return false\r\n\r\n        test.firstChild.className = 'b'\r\n        if (test.getElementsByClassName('b').length !== 2) return false\r\n\r\n        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one\r\n        test.innerHTML = '<a class=\"a\"></a><a class=\"f b a\"></a>'\r\n        if (test.getElementsByClassName('a').length !== 2) return false\r\n\r\n        // tests passed\r\n        return true\r\n    },\r\n\r\n    // no need to know\r\n\r\n    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){\r\n    //     test.innerHTML = '<a name=\"'+ id +'\"></a><b id=\"'+ id +'\"></b>'\r\n    //     return this.getElementById(id) !== test.firstChild\r\n    // },\r\n\r\n    // this is always checked for and fixed\r\n\r\n    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){\r\n    //\r\n    //     // IE returns comment nodes for getElementsByTagName('*') for some documents\r\n    //     test.appendChild(this.createComment(''))\r\n    //     if (test.getElementsByTagName('*').length > 0) return false\r\n    //\r\n    //     // IE returns closed nodes (EG:\"</foo>\") for getElementsByTagName('*') for some documents\r\n    //     test.innerHTML = 'foo</foo>'\r\n    //     if (test.getElementsByTagName('*').length) return false\r\n    //\r\n    //     // tests passed\r\n    //     return true\r\n    // },\r\n\r\n    // this is always checked for and fixed\r\n\r\n    // STAR_QUERY_SELECTOR: function(test){\r\n    //\r\n    //     // returns closed nodes (EG:\"</foo>\") for querySelector('*') for some documents\r\n    //     test.innerHTML = 'foo</foo>'\r\n    //     return !!(test.querySelectorAll('*').length)\r\n    // },\r\n\r\n    GET_ATTRIBUTE: function(test){\r\n        // tests for working getAttribute implementation\r\n        var shout = \"fus ro dah\"\r\n        test.innerHTML = '<a class=\"' + shout + '\"></a>'\r\n        return test.firstChild.getAttribute('class') === shout\r\n    }\r\n\r\n}\r\n\r\n// Finder\r\n\r\nvar Finder = function Finder(document){\r\n\r\n    this.document        = document\r\n    var root = this.root = document.documentElement\r\n    this.tested          = {}\r\n\r\n    // uniqueID\r\n\r\n    this.uniqueID = this.has(\"EXPANDOS\") ? uniqueID : uniqueIDXML\r\n\r\n    // getAttribute\r\n\r\n    this.getAttribute = (this.has(\"GET_ATTRIBUTE\")) ? function(node, name){\r\n\r\n        return node.getAttribute(name)\r\n\r\n    } : function(node, name){\r\n\r\n        node = node.getAttributeNode(name)\r\n        return (node && node.specified) ? node.value : null\r\n\r\n    }\r\n\r\n    // hasAttribute\r\n\r\n    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){\r\n\r\n        return node.hasAttribute(attribute)\r\n\r\n    } : function(node, attribute) {\r\n\r\n        node = node.getAttributeNode(attribute)\r\n        return !!(node && node.specified)\r\n\r\n    }\r\n\r\n    // contains\r\n\r\n    this.contains = (document.contains && root.contains) ? function(context, node){\r\n\r\n        return context.contains(node)\r\n\r\n    } : (root.compareDocumentPosition) ? function(context, node){\r\n\r\n        return context === node || !!(context.compareDocumentPosition(node) & 16)\r\n\r\n    } : function(context, node){\r\n\r\n        do {\r\n            if (node === context) return true\r\n        } while ((node = node.parentNode))\r\n\r\n        return false\r\n    }\r\n\r\n    // sort\r\n    // credits to Sizzle (http://sizzlejs.com/)\r\n\r\n    this.sorter = (root.compareDocumentPosition) ? function(a, b){\r\n\r\n        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0\r\n        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1\r\n\r\n    } : ('sourceIndex' in root) ? function(a, b){\r\n\r\n        if (!a.sourceIndex || !b.sourceIndex) return 0\r\n        return a.sourceIndex - b.sourceIndex\r\n\r\n    } : (document.createRange) ? function(a, b){\r\n\r\n        if (!a.ownerDocument || !b.ownerDocument) return 0\r\n        var aRange = a.ownerDocument.createRange(),\r\n            bRange = b.ownerDocument.createRange()\r\n\r\n        aRange.setStart(a, 0)\r\n        aRange.setEnd(a, 0)\r\n        bRange.setStart(b, 0)\r\n        bRange.setEnd(b, 0)\r\n        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)\r\n\r\n    } : null\r\n\r\n    this.failed = {}\r\n\r\n    var nativeMatches = this.has(\"MATCHES_SELECTOR\")\r\n\r\n    if (nativeMatches) this.matchesSelector = function(node, expression){\r\n\r\n        if (this.failed[expression]) return null\r\n\r\n        try {\r\n            return nativeMatches.call(node, expression)\r\n        } catch(e){\r\n            if (slick.debug) console.warn(\"matchesSelector failed on \" + expression)\r\n            this.failed[expression] = true\r\n            return null\r\n        }\r\n\r\n    }\r\n\r\n    if (this.has(\"QUERY_SELECTOR\")){\r\n\r\n        this.querySelectorAll = function(node, expression){\r\n\r\n            if (this.failed[expression]) return true\r\n\r\n            var result, _id, _expression, _combinator, _node\r\n\r\n\r\n            // non-document rooted QSA\r\n            // credits to Andrew Dupont\r\n\r\n            if (node !== this.document){\r\n\r\n                _combinator = expression[0].combinator\r\n\r\n                _id         = node.getAttribute(\"id\")\r\n                _expression = expression\r\n\r\n                if (!_id){\r\n                    _node = node\r\n                    _id = \"__slick__\"\r\n                    _node.setAttribute(\"id\", _id)\r\n                }\r\n\r\n                expression = \"#\" + _id + \" \" + _expression\r\n\r\n\r\n                // these combinators need a parentNode due to how querySelectorAll works, which is:\r\n                // finding all the elements that match the given selector\r\n                // then filtering by the ones that have the specified element as an ancestor\r\n                if (_combinator.indexOf(\"~\") > -1 || _combinator.indexOf(\"+\") > -1){\r\n\r\n                    node = node.parentNode\r\n                    if (!node) result = true\r\n                    // if node has no parentNode, we return \"true\" as if it failed, without polluting the failed cache\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (!result) try {\r\n                result = node.querySelectorAll(expression.toString())\r\n            } catch(e){\r\n                if (slick.debug) console.warn(\"querySelectorAll failed on \" + (_expression || expression))\r\n                result = this.failed[_expression || expression] = true\r\n            }\r\n\r\n            if (_node) _node.removeAttribute(\"id\")\r\n\r\n            return result\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nFinder.prototype.has = function(FEATURE){\r\n\r\n    var tested        = this.tested,\r\n        testedFEATURE = tested[FEATURE]\r\n\r\n    if (testedFEATURE != null) return testedFEATURE\r\n\r\n    var root     = this.root,\r\n        document = this.document,\r\n        testNode = document.createElement(\"div\")\r\n\r\n    testNode.setAttribute(\"style\", \"display: none;\")\r\n\r\n    root.appendChild(testNode)\r\n\r\n    var TEST = HAS[FEATURE], result = false\r\n\r\n    if (TEST) try {\r\n        result = TEST.call(document, testNode)\r\n    } catch(e){}\r\n\r\n    if (slick.debug && !result) console.warn(\"document has no \" + FEATURE)\r\n\r\n    root.removeChild(testNode)\r\n\r\n    return tested[FEATURE] = result\r\n\r\n}\r\n\r\nvar combinators = {\r\n\r\n    \" \": function(node, part, push){\r\n\r\n        var item, items\r\n\r\n        var noId = !part.id, noTag = !part.tag, noClass = !part.classes\r\n\r\n        if (part.id && node.getElementById && this.has(\"GET_ELEMENT_BY_ID\")){\r\n            item = node.getElementById(part.id)\r\n\r\n            // return only if id is found, else keep checking\r\n            // might be a tad slower on non-existing ids, but less insane\r\n\r\n            if (item && item.getAttribute('id') === part.id){\r\n                items = [item]\r\n                noId = true\r\n                // if tag is star, no need to check it in match()\r\n                if (part.tag === \"*\") noTag = true\r\n            }\r\n        }\r\n\r\n        if (!items){\r\n\r\n            if (part.classes && node.getElementsByClassName && this.has(\"GET_ELEMENTS_BY_CLASS_NAME\")){\r\n                items = node.getElementsByClassName(part.classList)\r\n                noClass = true\r\n                // if tag is star, no need to check it in match()\r\n                if (part.tag === \"*\") noTag = true\r\n            } else {\r\n                items = node.getElementsByTagName(part.tag)\r\n                // if tag is star, need to check it in match because it could select junk, boho\r\n                if (part.tag !== \"*\") noTag = true\r\n            }\r\n\r\n            if (!items || !items.length) return false\r\n\r\n        }\r\n\r\n        for (var i = 0; item = items[i++];)\r\n            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))\r\n                push(item)\r\n\r\n        return true\r\n\r\n    },\r\n\r\n    \">\": function(node, part, push){ // direct children\r\n        if ((node = node.firstChild)) do {\r\n            if (node.nodeType == 1 && this.match(node, part)) push(node)\r\n        } while ((node = node.nextSibling))\r\n    },\r\n\r\n    \"+\": function(node, part, push){ // next sibling\r\n        while ((node = node.nextSibling)) if (node.nodeType == 1){\r\n            if (this.match(node, part)) push(node)\r\n            break\r\n        }\r\n    },\r\n\r\n    \"^\": function(node, part, push){ // first child\r\n        node = node.firstChild\r\n        if (node){\r\n            if (node.nodeType === 1){\r\n                if (this.match(node, part)) push(node)\r\n            } else {\r\n                combinators['+'].call(this, node, part, push)\r\n            }\r\n        }\r\n    },\r\n\r\n    \"~\": function(node, part, push){ // next siblings\r\n        while ((node = node.nextSibling)){\r\n            if (node.nodeType === 1 && this.match(node, part)) push(node)\r\n        }\r\n    },\r\n\r\n    \"++\": function(node, part, push){ // next sibling and previous sibling\r\n        combinators['+'].call(this, node, part, push)\r\n        combinators['!+'].call(this, node, part, push)\r\n    },\r\n\r\n    \"~~\": function(node, part, push){ // next siblings and previous siblings\r\n        combinators['~'].call(this, node, part, push)\r\n        combinators['!~'].call(this, node, part, push)\r\n    },\r\n\r\n    \"!\": function(node, part, push){ // all parent nodes up to document\r\n        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)\r\n    },\r\n\r\n    \"!>\": function(node, part, push){ // direct parent (one level)\r\n        node = node.parentNode\r\n        if (node !== this.document && this.match(node, part)) push(node)\r\n    },\r\n\r\n    \"!+\": function(node, part, push){ // previous sibling\r\n        while ((node = node.previousSibling)) if (node.nodeType == 1){\r\n            if (this.match(node, part)) push(node)\r\n            break\r\n        }\r\n    },\r\n\r\n    \"!^\": function(node, part, push){ // last child\r\n        node = node.lastChild\r\n        if (node){\r\n            if (node.nodeType == 1){\r\n                if (this.match(node, part)) push(node)\r\n            } else {\r\n                combinators['!+'].call(this, node, part, push)\r\n            }\r\n        }\r\n    },\r\n\r\n    \"!~\": function(node, part, push){ // previous siblings\r\n        while ((node = node.previousSibling)){\r\n            if (node.nodeType === 1 && this.match(node, part)) push(node)\r\n        }\r\n    }\r\n\r\n}\r\n\r\nFinder.prototype.search = function(context, expression, found){\r\n\r\n    if (!context) context = this.document\r\n    else if (!context.nodeType && context.document) context = context.document\r\n\r\n    var expressions = parse(expression)\r\n\r\n    // no expressions were parsed. todo: is this really necessary?\r\n    if (!expressions || !expressions.length) throw new Error(\"invalid expression\")\r\n\r\n    if (!found) found = []\r\n\r\n    var uniques, push = isArray(found) ? function(node){\r\n        found[found.length] = node\r\n    } : function(node){\r\n        found[found.length++] = node\r\n    }\r\n\r\n    // if there is more than one expression we need to check for duplicates when we push to found\r\n    // this simply saves the old push and wraps it around an uid dupe check.\r\n    if (expressions.length > 1){\r\n        uniques = {}\r\n        var plush = push\r\n        push = function(node){\r\n            var uid = uniqueID(node)\r\n            if (!uniques[uid]){\r\n                uniques[uid] = true\r\n                plush(node)\r\n            }\r\n        }\r\n    }\r\n\r\n    // walker\r\n\r\n    var node, nodes, part\r\n\r\n    main: for (var i = 0; expression = expressions[i++];){\r\n\r\n        // querySelector\r\n\r\n        // TODO: more functional tests\r\n\r\n        // if there is querySelectorAll (and the expression does not fail) use it.\r\n        if (!slick.noQSA && this.querySelectorAll){\r\n\r\n            nodes = this.querySelectorAll(context, expression)\r\n            if (nodes !== true){\r\n                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){\r\n                    push(node)\r\n                }\r\n                continue main\r\n            }\r\n        }\r\n\r\n        // if there is only one part in the expression we don't need to check each part for duplicates.\r\n        // todo: this might be too naive. while solid, there can be expression sequences that do not\r\n        // produce duplicates. \"body div\" for instance, can never give you each div more than once.\r\n        // \"body div a\" on the other hand might.\r\n        if (expression.length === 1){\r\n\r\n            part = expression[0]\r\n            combinators[part.combinator].call(this, context, part, push)\r\n\r\n        } else {\r\n\r\n            var cs = [context], c, f, u, p = function(node){\r\n                var uid = uniqueID(node)\r\n                if (!u[uid]){\r\n                    u[uid] = true\r\n                    f[f.length] = node\r\n                }\r\n            }\r\n\r\n            // loop the expression parts\r\n            for (var j = 0; part = expression[j++];){\r\n                f = []; u = {}\r\n                // loop the contexts\r\n                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)\r\n                // nothing was found, the expression failed, continue to the next expression.\r\n                if (!f.length) continue main\r\n                cs = f // set the contexts for future parts (if any)\r\n            }\r\n\r\n            if (i === 0) found = f // first expression. directly set found.\r\n            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.\r\n        }\r\n\r\n    }\r\n\r\n    if (uniques && found && found.length > 1) this.sort(found)\r\n\r\n    return found\r\n\r\n}\r\n\r\nFinder.prototype.sort = function(nodes){\r\n    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes\r\n}\r\n\r\n// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.\r\n\r\nvar pseudos = {\r\n\r\n\r\n    // TODO: returns different results than qsa empty.\r\n\r\n    'empty': function(){\r\n        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length\r\n    },\r\n\r\n    'not': function(expression){\r\n        return !slick.matches(this, expression)\r\n    },\r\n\r\n    'contains': function(text){\r\n        return (this.innerText || this.textContent || '').indexOf(text) > -1\r\n    },\r\n\r\n    'first-child': function(){\r\n        var node = this\r\n        while ((node = node.previousSibling)) if (node.nodeType == 1) return false\r\n        return true\r\n    },\r\n\r\n    'last-child': function(){\r\n        var node = this\r\n        while ((node = node.nextSibling)) if (node.nodeType == 1) return false\r\n        return true\r\n    },\r\n\r\n    'only-child': function(){\r\n        var prev = this\r\n        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false\r\n\r\n        var next = this\r\n        while ((next = next.nextSibling)) if (next.nodeType == 1) return false\r\n\r\n        return true\r\n    },\r\n\r\n    'first-of-type': function(){\r\n        var node = this, nodeName = node.nodeName\r\n        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false\r\n        return true\r\n    },\r\n\r\n    'last-of-type': function(){\r\n        var node = this, nodeName = node.nodeName\r\n        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false\r\n        return true\r\n    },\r\n\r\n    'only-of-type': function(){\r\n        var prev = this, nodeName = this.nodeName\r\n        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false\r\n        var next = this\r\n        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false\r\n        return true\r\n    },\r\n\r\n    'enabled': function(){\r\n        return !this.disabled\r\n    },\r\n\r\n    'disabled': function(){\r\n        return this.disabled\r\n    },\r\n\r\n    'checked': function(){\r\n        return this.checked || this.selected\r\n    },\r\n\r\n    'selected': function(){\r\n        return this.selected\r\n    },\r\n\r\n    'focus': function(){\r\n        var doc = this.ownerDocument\r\n        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))\r\n    },\r\n\r\n    'root': function(){\r\n        return (this === this.ownerDocument.documentElement)\r\n    }\r\n\r\n}\r\n\r\nFinder.prototype.match = function(node, bit, noTag, noId, noClass){\r\n\r\n    // TODO: more functional tests ?\r\n\r\n    if (!slick.noQSA && this.matchesSelector){\r\n        var matches = this.matchesSelector(node, bit)\r\n        if (matches !== null) return matches\r\n    }\r\n\r\n    // normal matching\r\n\r\n    if (!noTag && bit.tag){\r\n\r\n        var nodeName = node.nodeName.toLowerCase()\r\n        if (bit.tag === \"*\"){\r\n            if (nodeName < \"@\") return false\r\n        } else if (nodeName != bit.tag){\r\n            return false\r\n        }\r\n\r\n    }\r\n\r\n    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false\r\n\r\n    var i, part\r\n\r\n    if (!noClass && bit.classes){\r\n\r\n        var className = this.getAttribute(node, \"class\")\r\n        if (!className) return false\r\n\r\n        for (part in bit.classes) if (!RegExp('(^|\\\\s)' + bit.classes[part] + '(\\\\s|$)').test(className)) return false\r\n    }\r\n\r\n    var name, value\r\n\r\n    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){\r\n\r\n        var operator  = part.operator,\r\n            escaped   = part.escapedValue\r\n\r\n        name  = part.name\r\n        value = part.value\r\n\r\n        if (!operator){\r\n\r\n            if (!this.hasAttribute(node, name)) return false\r\n\r\n        } else {\r\n\r\n            var actual = this.getAttribute(node, name)\r\n            if (actual == null) return false\r\n\r\n            switch (operator){\r\n                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break\r\n                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break\r\n                case '~=' : if (!RegExp('(^|\\\\s)' + escaped + '(\\\\s|$)').test(actual)) return false; break\r\n                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break\r\n\r\n                case '='  : if (actual !== value) return false; break\r\n                case '*=' : if (actual.indexOf(value) === -1) return false; break\r\n                default   : return false\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){\r\n\r\n        name  = part.name\r\n        value = part.value\r\n\r\n        if (pseudos[name]) return pseudos[name].call(node, value)\r\n\r\n        if (value != null){\r\n            if (this.getAttribute(node, name) !== value) return false\r\n        } else {\r\n            if (!this.hasAttribute(node, name)) return false\r\n        }\r\n\r\n    }\r\n\r\n    return true\r\n\r\n}\r\n\r\nFinder.prototype.matches = function(node, expression){\r\n\r\n    var expressions = parse(expression)\r\n\r\n    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match\r\n        return this.match(node, expressions[0][0])\r\n    }\r\n\r\n    // TODO: more functional tests ?\r\n\r\n    if (!slick.noQSA && this.matchesSelector){\r\n        var matches = this.matchesSelector(node, expressions)\r\n        if (matches !== null) return matches\r\n    }\r\n\r\n    var nodes = this.search(this.document, expression, {length: 0})\r\n\r\n    for (var i = 0, res; res = nodes[i++];) if (node === res) return true\r\n    return false\r\n\r\n}\r\n\r\nvar finders = {}\r\n\r\nvar finder = function(context){\r\n    var doc = context || document\r\n    if (doc.ownerDocument) doc = doc.ownerDocument\r\n    else if (doc.document) doc = doc.document\r\n\r\n    if (doc.nodeType !== 9) throw new TypeError(\"invalid document\")\r\n\r\n    var uid = uniqueID(doc)\r\n    return finders[uid] || (finders[uid] = new Finder(doc))\r\n}\r\n\r\n// ... API ...\r\n\r\nvar slick = function(expression, context){\r\n    return slick.search(expression, context)\r\n}\r\n\r\nslick.search = function(expression, context, found){\r\n    return finder(context).search(context, expression, found)\r\n}\r\n\r\nslick.find = function(expression, context){\r\n    return finder(context).search(context, expression)[0] || null\r\n}\r\n\r\nslick.getAttribute = function(node, name){\r\n    return finder(node).getAttribute(node, name)\r\n}\r\n\r\nslick.hasAttribute = function(node, name){\r\n    return finder(node).hasAttribute(node, name)\r\n}\r\n\r\nslick.contains = function(context, node){\r\n    return finder(context).contains(context, node)\r\n}\r\n\r\nslick.matches = function(node, expression){\r\n    return finder(node).matches(node, expression)\r\n}\r\n\r\nslick.sort = function(nodes){\r\n    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)\r\n    return nodes\r\n}\r\n\r\nslick.parse = parse;\r\n\r\n// slick.debug = true\r\n// slick.noQSA  = true\r\n\r\nmodule.exports = slick\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2xpY2svZmluZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxFQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsc0RBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLFVBQVU7QUFDVixLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0JBQWtCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQsd0JBQXdCO0FBQ3hCO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckcscUdBQXFHO0FBQ3JHLHFHQUFxRztBQUNyRyxxR0FBcUc7QUFDckc7QUFDQSxnRUFBZ0U7QUFDaEUsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1cmFjZWwtcGVvcGxlLy4vbm9kZV9tb2R1bGVzL3NsaWNrL2ZpbmRlci5qcz85YWIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblNsaWNrIEZpbmRlclxyXG4qL1widXNlIHN0cmljdFwiXHJcblxyXG4vLyBOb3RhYmxlIGNoYW5nZXMgZnJvbSBTbGljay5GaW5kZXIgMS4wLnhcclxuXHJcbi8vIGZhc3RlciBib3R0b20gLT4gdXAgZXhwcmVzc2lvbiBtYXRjaGluZ1xyXG4vLyBwcmVmZXJzIG1lbnRhbCBzYW5pdHkgb3ZlciAqb2JzZXNzaXZlIGNvbXB1bHNpdmUqIG1pbGxpc2Vjb25kcyBzYXZpbmdzXHJcbi8vIHVzZXMgcHJvdG90eXBlcyBpbnN0ZWFkIG9mIG9iamVjdHNcclxuLy8gdHJpZXMgdG8gdXNlIG1hdGNoZXNTZWxlY3RvciBzbWFydGx5LCB3aGVuZXZlciBhdmFpbGFibGVcclxuLy8gY2FuIHBvcHVsYXRlIG9iamVjdHMgYXMgd2VsbCBhcyBhcnJheXNcclxuLy8gbG90cyBvZiBzdHVmZiBpcyBicm9rZW4gb3Igbm90IGltcGxlbWVudGVkXHJcblxyXG52YXIgcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZXJcIilcclxuXHJcbi8vIHV0aWxpdGllc1xyXG5cclxudmFyIGluZGV4ID0gMCxcclxuICAgIGNvdW50ZXIgPSBkb2N1bWVudC5fX2NvdW50ZXIgPSAocGFyc2VJbnQoZG9jdW1lbnQuX19jb3VudGVyIHx8IC0xLCAzNikgKyAxKS50b1N0cmluZygzNiksXHJcbiAgICBrZXkgPSBcInVpZDpcIiArIGNvdW50ZXJcclxuXHJcbnZhciB1bmlxdWVJRCA9IGZ1bmN0aW9uKG4sIHhtbCl7XHJcbiAgICBpZiAobiA9PT0gd2luZG93KSByZXR1cm4gXCJ3aW5kb3dcIlxyXG4gICAgaWYgKG4gPT09IGRvY3VtZW50KSByZXR1cm4gXCJkb2N1bWVudFwiXHJcbiAgICBpZiAobiA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSByZXR1cm4gXCJodG1sXCJcclxuXHJcbiAgICBpZiAoeG1sKSB7XHJcbiAgICAgICAgdmFyIHVpZCA9IG4uZ2V0QXR0cmlidXRlKGtleSlcclxuICAgICAgICBpZiAoIXVpZCkge1xyXG4gICAgICAgICAgICB1aWQgPSAoaW5kZXgrKykudG9TdHJpbmcoMzYpXHJcbiAgICAgICAgICAgIG4uc2V0QXR0cmlidXRlKGtleSwgdWlkKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdWlkXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuW2tleV0gfHwgKG5ba2V5XSA9IChpbmRleCsrKS50b1N0cmluZygzNikpXHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB1bmlxdWVJRFhNTCA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHJldHVybiB1bmlxdWVJRChuLCB0cnVlKVxyXG59XHJcblxyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqZWN0KXtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXHJcbn1cclxuXHJcbi8vIHRlc3RzXHJcblxyXG52YXIgdW5pcXVlSW5kZXggPSAwO1xyXG5cclxudmFyIEhBUyA9IHtcclxuXHJcbiAgICBHRVRfRUxFTUVOVF9CWV9JRDogZnVuY3Rpb24odGVzdCwgaWQpe1xyXG4gICAgICAgIGlkID0gXCJzbGlja19cIiArICh1bmlxdWVJbmRleCsrKTtcclxuICAgICAgICAvLyBjaGVja3MgaWYgdGhlIGRvY3VtZW50IGhhcyBnZXRFbGVtZW50QnlJZCwgYW5kIGl0IHdvcmtzXHJcbiAgICAgICAgdGVzdC5pbm5lckhUTUwgPSAnPGEgaWQ9XCInICsgaWQgKyAnXCI+PC9hPidcclxuICAgICAgICByZXR1cm4gISF0aGlzLmdldEVsZW1lbnRCeUlkKGlkKVxyXG4gICAgfSxcclxuXHJcbiAgICBRVUVSWV9TRUxFQ1RPUjogZnVuY3Rpb24odGVzdCl7XHJcbiAgICAgICAgLy8gdGhpcyBzdXBwb3NlZGx5IGZpeGVzIGEgd2Via2l0IGJ1ZyB3aXRoIG1hdGNoZXNTZWxlY3RvciAvIHF1ZXJ5U2VsZWN0b3IgJiBudGgtY2hpbGRcclxuICAgICAgICB0ZXN0LmlubmVySFRNTCA9ICdfPHN0eWxlPjpudGgtY2hpbGQoMil7fTwvc3R5bGU+J1xyXG5cclxuICAgICAgICAvLyBjaGVja3MgaWYgdGhlIGRvY3VtZW50IGhhcyBxdWVyeVNlbGVjdG9yQWxsLCBhbmQgaXQgd29ya3NcclxuICAgICAgICB0ZXN0LmlubmVySFRNTCA9ICc8YSBjbGFzcz1cIk1pWFwiPjwvYT4nXHJcblxyXG4gICAgICAgIHJldHVybiB0ZXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJy5NaVgnKS5sZW5ndGggPT09IDFcclxuICAgIH0sXHJcblxyXG4gICAgRVhQQU5ET1M6IGZ1bmN0aW9uKHRlc3QsIGlkKXtcclxuICAgICAgICBpZCA9IFwic2xpY2tfXCIgKyAodW5pcXVlSW5kZXgrKyk7XHJcbiAgICAgICAgLy8gY2hlY2tzIGlmIHRoZSBkb2N1bWVudCBoYXMgZWxlbWVudHMgdGhhdCBzdXBwb3J0IGV4cGFuZG9zXHJcbiAgICAgICAgdGVzdC5fY3VzdG9tX3Byb3BlcnR5XyA9IGlkXHJcbiAgICAgICAgcmV0dXJuIHRlc3QuX2N1c3RvbV9wcm9wZXJ0eV8gPT09IGlkXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRPRE86IHVzZSB0aGlzID9cclxuXHJcbiAgICAvLyBDSEVDS0VEX1FVRVJZX1NFTEVDVE9SOiBmdW5jdGlvbih0ZXN0KXtcclxuICAgIC8vXHJcbiAgICAvLyAgICAgLy8gY2hlY2tzIGlmIHRoZSBkb2N1bWVudCBzdXBwb3J0cyB0aGUgY2hlY2tlZCBxdWVyeSBzZWxlY3RvclxyXG4gICAgLy8gICAgIHRlc3QuaW5uZXJIVE1MID0gJzxzZWxlY3Q+PG9wdGlvbiBzZWxlY3RlZD1cInNlbGVjdGVkXCI+YTwvb3B0aW9uPjwvc2VsZWN0PidcclxuICAgIC8vICAgICByZXR1cm4gdGVzdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLmxlbmd0aCA9PT0gMVxyXG4gICAgLy8gfSxcclxuXHJcbiAgICAvLyBUT0RPOiB1c2UgdGhpcyA/XHJcblxyXG4gICAgLy8gRU1QVFlfQVRUUklCVVRFX1FVRVJZX1NFTEVDVE9SOiBmdW5jdGlvbih0ZXN0KXtcclxuICAgIC8vXHJcbiAgICAvLyAgICAgLy8gY2hlY2tzIGlmIHRoZSBkb2N1bWVudCBzdXBwb3J0cyB0aGUgZW1wdHkgYXR0cmlidXRlIHF1ZXJ5IHNlbGVjdG9yXHJcbiAgICAvLyAgICAgdGVzdC5pbm5lckhUTUwgPSAnPGEgY2xhc3M9XCJcIj48L2E+J1xyXG4gICAgLy8gICAgIHJldHVybiB0ZXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjbGFzcyo9XCJcIl0nKS5sZW5ndGggPT09IDFcclxuICAgIC8vIH0sXHJcblxyXG4gICAgTUFUQ0hFU19TRUxFQ1RPUjogZnVuY3Rpb24odGVzdCl7XHJcblxyXG4gICAgICAgIHRlc3QuY2xhc3NOYW1lID0gXCJNaVhcIlxyXG5cclxuICAgICAgICAvLyBjaGVja3MgaWYgdGhlIGRvY3VtZW50IGhhcyBtYXRjaGVzU2VsZWN0b3IsIGFuZCB3ZSBjYW4gdXNlIGl0LlxyXG5cclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHRlc3QubWF0Y2hlc1NlbGVjdG9yIHx8IHRlc3QubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHRlc3Qud2Via2l0TWF0Y2hlc1NlbGVjdG9yXHJcblxyXG4gICAgICAgIC8vIGlmIG1hdGNoZXNTZWxlY3RvciB0cm93cyBlcnJvcnMgb24gaW5jb3JyZWN0IHN5bnRheCB3ZSBjYW4gdXNlIGl0XHJcbiAgICAgICAgaWYgKG1hdGNoZXMpIHRyeSB7XHJcbiAgICAgICAgICAgIG1hdGNoZXMuY2FsbCh0ZXN0LCAnOnNsaWNrJylcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICAvLyBqdXN0IGFzIGEgc2FmZXR5IHByZWNhdXRpb24sIGFsc28gdGVzdCBpZiBpdCB3b3JrcyBvbiBtaXhlZGNhc2UgKGxpa2UgcXVlcnlTZWxlY3RvckFsbClcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbCh0ZXN0LCBcIi5NaVhcIikgPyBtYXRjaGVzIDogZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICBHRVRfRUxFTUVOVFNfQllfQ0xBU1NfTkFNRTogZnVuY3Rpb24odGVzdCl7XHJcbiAgICAgICAgdGVzdC5pbm5lckhUTUwgPSAnPGEgY2xhc3M9XCJmXCI+PC9hPjxhIGNsYXNzPVwiYlwiPjwvYT4nXHJcbiAgICAgICAgaWYgKHRlc3QuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYicpLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgICAgIHRlc3QuZmlyc3RDaGlsZC5jbGFzc05hbWUgPSAnYidcclxuICAgICAgICBpZiAodGVzdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdiJykubGVuZ3RoICE9PSAyKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgLy8gT3BlcmEgOS42IGdldEVsZW1lbnRzQnlDbGFzc05hbWUgZG9lc250IGRldGVjdHMgdGhlIGNsYXNzIGlmIGl0cyBub3QgdGhlIGZpcnN0IG9uZVxyXG4gICAgICAgIHRlc3QuaW5uZXJIVE1MID0gJzxhIGNsYXNzPVwiYVwiPjwvYT48YSBjbGFzcz1cImYgYiBhXCI+PC9hPidcclxuICAgICAgICBpZiAodGVzdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhJykubGVuZ3RoICE9PSAyKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgLy8gdGVzdHMgcGFzc2VkXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0sXHJcblxyXG4gICAgLy8gbm8gbmVlZCB0byBrbm93XHJcblxyXG4gICAgLy8gR0VUX0VMRU1FTlRfQllfSURfTk9UX05BTUU6IGZ1bmN0aW9uKHRlc3QsIGlkKXtcclxuICAgIC8vICAgICB0ZXN0LmlubmVySFRNTCA9ICc8YSBuYW1lPVwiJysgaWQgKydcIj48L2E+PGIgaWQ9XCInKyBpZCArJ1wiPjwvYj4nXHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudEJ5SWQoaWQpICE9PSB0ZXN0LmZpcnN0Q2hpbGRcclxuICAgIC8vIH0sXHJcblxyXG4gICAgLy8gdGhpcyBpcyBhbHdheXMgY2hlY2tlZCBmb3IgYW5kIGZpeGVkXHJcblxyXG4gICAgLy8gU1RBUl9HRVRfRUxFTUVOVFNfQllfVEFHX05BTUU6IGZ1bmN0aW9uKHRlc3Qpe1xyXG4gICAgLy9cclxuICAgIC8vICAgICAvLyBJRSByZXR1cm5zIGNvbW1lbnQgbm9kZXMgZm9yIGdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykgZm9yIHNvbWUgZG9jdW1lbnRzXHJcbiAgICAvLyAgICAgdGVzdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUNvbW1lbnQoJycpKVxyXG4gICAgLy8gICAgIGlmICh0ZXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykubGVuZ3RoID4gMCkgcmV0dXJuIGZhbHNlXHJcbiAgICAvL1xyXG4gICAgLy8gICAgIC8vIElFIHJldHVybnMgY2xvc2VkIG5vZGVzIChFRzpcIjwvZm9vPlwiKSBmb3IgZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSBmb3Igc29tZSBkb2N1bWVudHNcclxuICAgIC8vICAgICB0ZXN0LmlubmVySFRNTCA9ICdmb288L2Zvbz4nXHJcbiAgICAvLyAgICAgaWYgKHRlc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKS5sZW5ndGgpIHJldHVybiBmYWxzZVxyXG4gICAgLy9cclxuICAgIC8vICAgICAvLyB0ZXN0cyBwYXNzZWRcclxuICAgIC8vICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgLy8gfSxcclxuXHJcbiAgICAvLyB0aGlzIGlzIGFsd2F5cyBjaGVja2VkIGZvciBhbmQgZml4ZWRcclxuXHJcbiAgICAvLyBTVEFSX1FVRVJZX1NFTEVDVE9SOiBmdW5jdGlvbih0ZXN0KXtcclxuICAgIC8vXHJcbiAgICAvLyAgICAgLy8gcmV0dXJucyBjbG9zZWQgbm9kZXMgKEVHOlwiPC9mb28+XCIpIGZvciBxdWVyeVNlbGVjdG9yKCcqJykgZm9yIHNvbWUgZG9jdW1lbnRzXHJcbiAgICAvLyAgICAgdGVzdC5pbm5lckhUTUwgPSAnZm9vPC9mb28+J1xyXG4gICAgLy8gICAgIHJldHVybiAhISh0ZXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKS5sZW5ndGgpXHJcbiAgICAvLyB9LFxyXG5cclxuICAgIEdFVF9BVFRSSUJVVEU6IGZ1bmN0aW9uKHRlc3Qpe1xyXG4gICAgICAgIC8vIHRlc3RzIGZvciB3b3JraW5nIGdldEF0dHJpYnV0ZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgIHZhciBzaG91dCA9IFwiZnVzIHJvIGRhaFwiXHJcbiAgICAgICAgdGVzdC5pbm5lckhUTUwgPSAnPGEgY2xhc3M9XCInICsgc2hvdXQgKyAnXCI+PC9hPidcclxuICAgICAgICByZXR1cm4gdGVzdC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA9PT0gc2hvdXRcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8vIEZpbmRlclxyXG5cclxudmFyIEZpbmRlciA9IGZ1bmN0aW9uIEZpbmRlcihkb2N1bWVudCl7XHJcblxyXG4gICAgdGhpcy5kb2N1bWVudCAgICAgICAgPSBkb2N1bWVudFxyXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcclxuICAgIHRoaXMudGVzdGVkICAgICAgICAgID0ge31cclxuXHJcbiAgICAvLyB1bmlxdWVJRFxyXG5cclxuICAgIHRoaXMudW5pcXVlSUQgPSB0aGlzLmhhcyhcIkVYUEFORE9TXCIpID8gdW5pcXVlSUQgOiB1bmlxdWVJRFhNTFxyXG5cclxuICAgIC8vIGdldEF0dHJpYnV0ZVxyXG5cclxuICAgIHRoaXMuZ2V0QXR0cmlidXRlID0gKHRoaXMuaGFzKFwiR0VUX0FUVFJJQlVURVwiKSkgPyBmdW5jdGlvbihub2RlLCBuYW1lKXtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpXHJcblxyXG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpe1xyXG5cclxuICAgICAgICBub2RlID0gbm9kZS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpXHJcbiAgICAgICAgcmV0dXJuIChub2RlICYmIG5vZGUuc3BlY2lmaWVkKSA/IG5vZGUudmFsdWUgOiBudWxsXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGhhc0F0dHJpYnV0ZVxyXG5cclxuICAgIHRoaXMuaGFzQXR0cmlidXRlID0gKHJvb3QuaGFzQXR0cmlidXRlKSA/IGZ1bmN0aW9uKG5vZGUsIGF0dHJpYnV0ZSl7XHJcblxyXG4gICAgICAgIHJldHVybiBub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpXHJcblxyXG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUsIGF0dHJpYnV0ZSkge1xyXG5cclxuICAgICAgICBub2RlID0gbm9kZS5nZXRBdHRyaWJ1dGVOb2RlKGF0dHJpYnV0ZSlcclxuICAgICAgICByZXR1cm4gISEobm9kZSAmJiBub2RlLnNwZWNpZmllZClcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29udGFpbnNcclxuXHJcbiAgICB0aGlzLmNvbnRhaW5zID0gKGRvY3VtZW50LmNvbnRhaW5zICYmIHJvb3QuY29udGFpbnMpID8gZnVuY3Rpb24oY29udGV4dCwgbm9kZSl7XHJcblxyXG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbnRhaW5zKG5vZGUpXHJcblxyXG4gICAgfSA6IChyb290LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSA/IGZ1bmN0aW9uKGNvbnRleHQsIG5vZGUpe1xyXG5cclxuICAgICAgICByZXR1cm4gY29udGV4dCA9PT0gbm9kZSB8fCAhIShjb250ZXh0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgMTYpXHJcblxyXG4gICAgfSA6IGZ1bmN0aW9uKGNvbnRleHQsIG5vZGUpe1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSBjb250ZXh0KSByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH0gd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnROb2RlKSlcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc29ydFxyXG4gICAgLy8gY3JlZGl0cyB0byBTaXp6bGUgKGh0dHA6Ly9zaXp6bGVqcy5jb20vKVxyXG5cclxuICAgIHRoaXMuc29ydGVyID0gKHJvb3QuY29tcGFyZURvY3VtZW50UG9zaXRpb24pID8gZnVuY3Rpb24oYSwgYil7XHJcblxyXG4gICAgICAgIGlmICghYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiB8fCAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikgcmV0dXJuIDBcclxuICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDQgPyAtMSA6IGEgPT09IGIgPyAwIDogMVxyXG5cclxuICAgIH0gOiAoJ3NvdXJjZUluZGV4JyBpbiByb290KSA/IGZ1bmN0aW9uKGEsIGIpe1xyXG5cclxuICAgICAgICBpZiAoIWEuc291cmNlSW5kZXggfHwgIWIuc291cmNlSW5kZXgpIHJldHVybiAwXHJcbiAgICAgICAgcmV0dXJuIGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4XHJcblxyXG4gICAgfSA6IChkb2N1bWVudC5jcmVhdGVSYW5nZSkgPyBmdW5jdGlvbihhLCBiKXtcclxuXHJcbiAgICAgICAgaWYgKCFhLm93bmVyRG9jdW1lbnQgfHwgIWIub3duZXJEb2N1bWVudCkgcmV0dXJuIDBcclxuICAgICAgICB2YXIgYVJhbmdlID0gYS5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCksXHJcbiAgICAgICAgICAgIGJSYW5nZSA9IGIub3duZXJEb2N1bWVudC5jcmVhdGVSYW5nZSgpXHJcblxyXG4gICAgICAgIGFSYW5nZS5zZXRTdGFydChhLCAwKVxyXG4gICAgICAgIGFSYW5nZS5zZXRFbmQoYSwgMClcclxuICAgICAgICBiUmFuZ2Uuc2V0U3RhcnQoYiwgMClcclxuICAgICAgICBiUmFuZ2Uuc2V0RW5kKGIsIDApXHJcbiAgICAgICAgcmV0dXJuIGFSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoUmFuZ2UuU1RBUlRfVE9fRU5ELCBiUmFuZ2UpXHJcblxyXG4gICAgfSA6IG51bGxcclxuXHJcbiAgICB0aGlzLmZhaWxlZCA9IHt9XHJcblxyXG4gICAgdmFyIG5hdGl2ZU1hdGNoZXMgPSB0aGlzLmhhcyhcIk1BVENIRVNfU0VMRUNUT1JcIilcclxuXHJcbiAgICBpZiAobmF0aXZlTWF0Y2hlcykgdGhpcy5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBleHByZXNzaW9uKXtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZmFpbGVkW2V4cHJlc3Npb25dKSByZXR1cm4gbnVsbFxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlTWF0Y2hlcy5jYWxsKG5vZGUsIGV4cHJlc3Npb24pXHJcbiAgICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICAgICAgaWYgKHNsaWNrLmRlYnVnKSBjb25zb2xlLndhcm4oXCJtYXRjaGVzU2VsZWN0b3IgZmFpbGVkIG9uIFwiICsgZXhwcmVzc2lvbilcclxuICAgICAgICAgICAgdGhpcy5mYWlsZWRbZXhwcmVzc2lvbl0gPSB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5oYXMoXCJRVUVSWV9TRUxFQ1RPUlwiKSl7XHJcblxyXG4gICAgICAgIHRoaXMucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHJlc3Npb24pe1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZmFpbGVkW2V4cHJlc3Npb25dKSByZXR1cm4gdHJ1ZVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2lkLCBfZXhwcmVzc2lvbiwgX2NvbWJpbmF0b3IsIF9ub2RlXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gbm9uLWRvY3VtZW50IHJvb3RlZCBRU0FcclxuICAgICAgICAgICAgLy8gY3JlZGl0cyB0byBBbmRyZXcgRHVwb250XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5kb2N1bWVudCl7XHJcblxyXG4gICAgICAgICAgICAgICAgX2NvbWJpbmF0b3IgPSBleHByZXNzaW9uWzBdLmNvbWJpbmF0b3JcclxuXHJcbiAgICAgICAgICAgICAgICBfaWQgICAgICAgICA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIilcclxuICAgICAgICAgICAgICAgIF9leHByZXNzaW9uID0gZXhwcmVzc2lvblxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghX2lkKXtcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZSA9IG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBfaWQgPSBcIl9fc2xpY2tfX1wiXHJcbiAgICAgICAgICAgICAgICAgICAgX25vZGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgX2lkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBcIiNcIiArIF9pZCArIFwiIFwiICsgX2V4cHJlc3Npb25cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgY29tYmluYXRvcnMgbmVlZCBhIHBhcmVudE5vZGUgZHVlIHRvIGhvdyBxdWVyeVNlbGVjdG9yQWxsIHdvcmtzLCB3aGljaCBpczpcclxuICAgICAgICAgICAgICAgIC8vIGZpbmRpbmcgYWxsIHRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBmaWx0ZXJpbmcgYnkgdGhlIG9uZXMgdGhhdCBoYXZlIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBhcyBhbiBhbmNlc3RvclxyXG4gICAgICAgICAgICAgICAgaWYgKF9jb21iaW5hdG9yLmluZGV4T2YoXCJ+XCIpID4gLTEgfHwgX2NvbWJpbmF0b3IuaW5kZXhPZihcIitcIikgPiAtMSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHJlc3VsdCA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub2RlIGhhcyBubyBwYXJlbnROb2RlLCB3ZSByZXR1cm4gXCJ0cnVlXCIgYXMgaWYgaXQgZmFpbGVkLCB3aXRob3V0IHBvbGx1dGluZyB0aGUgZmFpbGVkIGNhY2hlXHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoZXhwcmVzc2lvbi50b1N0cmluZygpKVxyXG4gICAgICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsaWNrLmRlYnVnKSBjb25zb2xlLndhcm4oXCJxdWVyeVNlbGVjdG9yQWxsIGZhaWxlZCBvbiBcIiArIChfZXhwcmVzc2lvbiB8fCBleHByZXNzaW9uKSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmFpbGVkW19leHByZXNzaW9uIHx8IGV4cHJlc3Npb25dID0gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX25vZGUpIF9ub2RlLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5GaW5kZXIucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKEZFQVRVUkUpe1xyXG5cclxuICAgIHZhciB0ZXN0ZWQgICAgICAgID0gdGhpcy50ZXN0ZWQsXHJcbiAgICAgICAgdGVzdGVkRkVBVFVSRSA9IHRlc3RlZFtGRUFUVVJFXVxyXG5cclxuICAgIGlmICh0ZXN0ZWRGRUFUVVJFICE9IG51bGwpIHJldHVybiB0ZXN0ZWRGRUFUVVJFXHJcblxyXG4gICAgdmFyIHJvb3QgICAgID0gdGhpcy5yb290LFxyXG4gICAgICAgIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcclxuICAgICAgICB0ZXN0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuXHJcbiAgICB0ZXN0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6IG5vbmU7XCIpXHJcblxyXG4gICAgcm9vdC5hcHBlbmRDaGlsZCh0ZXN0Tm9kZSlcclxuXHJcbiAgICB2YXIgVEVTVCA9IEhBU1tGRUFUVVJFXSwgcmVzdWx0ID0gZmFsc2VcclxuXHJcbiAgICBpZiAoVEVTVCkgdHJ5IHtcclxuICAgICAgICByZXN1bHQgPSBURVNULmNhbGwoZG9jdW1lbnQsIHRlc3ROb2RlKVxyXG4gICAgfSBjYXRjaChlKXt9XHJcblxyXG4gICAgaWYgKHNsaWNrLmRlYnVnICYmICFyZXN1bHQpIGNvbnNvbGUud2FybihcImRvY3VtZW50IGhhcyBubyBcIiArIEZFQVRVUkUpXHJcblxyXG4gICAgcm9vdC5yZW1vdmVDaGlsZCh0ZXN0Tm9kZSlcclxuXHJcbiAgICByZXR1cm4gdGVzdGVkW0ZFQVRVUkVdID0gcmVzdWx0XHJcblxyXG59XHJcblxyXG52YXIgY29tYmluYXRvcnMgPSB7XHJcblxyXG4gICAgXCIgXCI6IGZ1bmN0aW9uKG5vZGUsIHBhcnQsIHB1c2gpe1xyXG5cclxuICAgICAgICB2YXIgaXRlbSwgaXRlbXNcclxuXHJcbiAgICAgICAgdmFyIG5vSWQgPSAhcGFydC5pZCwgbm9UYWcgPSAhcGFydC50YWcsIG5vQ2xhc3MgPSAhcGFydC5jbGFzc2VzXHJcblxyXG4gICAgICAgIGlmIChwYXJ0LmlkICYmIG5vZGUuZ2V0RWxlbWVudEJ5SWQgJiYgdGhpcy5oYXMoXCJHRVRfRUxFTUVOVF9CWV9JRFwiKSl7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBub2RlLmdldEVsZW1lbnRCeUlkKHBhcnQuaWQpXHJcblxyXG4gICAgICAgICAgICAvLyByZXR1cm4gb25seSBpZiBpZCBpcyBmb3VuZCwgZWxzZSBrZWVwIGNoZWNraW5nXHJcbiAgICAgICAgICAgIC8vIG1pZ2h0IGJlIGEgdGFkIHNsb3dlciBvbiBub24tZXhpc3RpbmcgaWRzLCBidXQgbGVzcyBpbnNhbmVcclxuXHJcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uZ2V0QXR0cmlidXRlKCdpZCcpID09PSBwYXJ0LmlkKXtcclxuICAgICAgICAgICAgICAgIGl0ZW1zID0gW2l0ZW1dXHJcbiAgICAgICAgICAgICAgICBub0lkID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGFnIGlzIHN0YXIsIG5vIG5lZWQgdG8gY2hlY2sgaXQgaW4gbWF0Y2goKVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQudGFnID09PSBcIipcIikgbm9UYWcgPSB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXRlbXMpe1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhcnQuY2xhc3NlcyAmJiBub2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgdGhpcy5oYXMoXCJHRVRfRUxFTUVOVFNfQllfQ0xBU1NfTkFNRVwiKSl7XHJcbiAgICAgICAgICAgICAgICBpdGVtcyA9IG5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShwYXJ0LmNsYXNzTGlzdClcclxuICAgICAgICAgICAgICAgIG5vQ2xhc3MgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0YWcgaXMgc3Rhciwgbm8gbmVlZCB0byBjaGVjayBpdCBpbiBtYXRjaCgpXHJcbiAgICAgICAgICAgICAgICBpZiAocGFydC50YWcgPT09IFwiKlwiKSBub1RhZyA9IHRydWVcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1zID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShwYXJ0LnRhZylcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRhZyBpcyBzdGFyLCBuZWVkIHRvIGNoZWNrIGl0IGluIG1hdGNoIGJlY2F1c2UgaXQgY291bGQgc2VsZWN0IGp1bmssIGJvaG9cclxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRhZyAhPT0gXCIqXCIpIG5vVGFnID0gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpdGVtID0gaXRlbXNbaSsrXTspXHJcbiAgICAgICAgICAgIGlmICgobm9UYWcgJiYgbm9JZCAmJiBub0NsYXNzICYmICFwYXJ0LmF0dHJpYnV0ZXMgJiYgIXBhcnQucHNldWRvcykgfHwgdGhpcy5tYXRjaChpdGVtLCBwYXJ0LCBub1RhZywgbm9JZCwgbm9DbGFzcykpXHJcbiAgICAgICAgICAgICAgICBwdXNoKGl0ZW0pXHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBcIj5cIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7IC8vIGRpcmVjdCBjaGlsZHJlblxyXG4gICAgICAgIGlmICgobm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkpIGRvIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLm1hdGNoKG5vZGUsIHBhcnQpKSBwdXNoKG5vZGUpXHJcbiAgICAgICAgfSB3aGlsZSAoKG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSlcclxuICAgIH0sXHJcblxyXG4gICAgXCIrXCI6IGZ1bmN0aW9uKG5vZGUsIHBhcnQsIHB1c2gpeyAvLyBuZXh0IHNpYmxpbmdcclxuICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSkgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKG5vZGUsIHBhcnQpKSBwdXNoKG5vZGUpXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBcIl5cIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7IC8vIGZpcnN0IGNoaWxkXHJcbiAgICAgICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZFxyXG4gICAgICAgIGlmIChub2RlKXtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpe1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2gobm9kZSwgcGFydCkpIHB1c2gobm9kZSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbWJpbmF0b3JzWycrJ10uY2FsbCh0aGlzLCBub2RlLCBwYXJ0LCBwdXNoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBcIn5cIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7IC8vIG5leHQgc2libGluZ3NcclxuICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSl7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmIHRoaXMubWF0Y2gobm9kZSwgcGFydCkpIHB1c2gobm9kZSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiKytcIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7IC8vIG5leHQgc2libGluZyBhbmQgcHJldmlvdXMgc2libGluZ1xyXG4gICAgICAgIGNvbWJpbmF0b3JzWycrJ10uY2FsbCh0aGlzLCBub2RlLCBwYXJ0LCBwdXNoKVxyXG4gICAgICAgIGNvbWJpbmF0b3JzWychKyddLmNhbGwodGhpcywgbm9kZSwgcGFydCwgcHVzaClcclxuICAgIH0sXHJcblxyXG4gICAgXCJ+flwiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gbmV4dCBzaWJsaW5ncyBhbmQgcHJldmlvdXMgc2libGluZ3NcclxuICAgICAgICBjb21iaW5hdG9yc1snfiddLmNhbGwodGhpcywgbm9kZSwgcGFydCwgcHVzaClcclxuICAgICAgICBjb21iaW5hdG9yc1snIX4nXS5jYWxsKHRoaXMsIG5vZGUsIHBhcnQsIHB1c2gpXHJcbiAgICB9LFxyXG5cclxuICAgIFwiIVwiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gYWxsIHBhcmVudCBub2RlcyB1cCB0byBkb2N1bWVudFxyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIGlmIChub2RlICE9PSB0aGlzLmRvY3VtZW50ICYmIHRoaXMubWF0Y2gobm9kZSwgcGFydCkpIHB1c2gobm9kZSlcclxuICAgIH0sXHJcblxyXG4gICAgXCIhPlwiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gZGlyZWN0IHBhcmVudCAob25lIGxldmVsKVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGVcclxuICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5kb2N1bWVudCAmJiB0aGlzLm1hdGNoKG5vZGUsIHBhcnQpKSBwdXNoKG5vZGUpXHJcbiAgICB9LFxyXG5cclxuICAgIFwiIStcIjogZnVuY3Rpb24obm9kZSwgcGFydCwgcHVzaCl7IC8vIHByZXZpb3VzIHNpYmxpbmdcclxuICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykpIGlmIChub2RlLm5vZGVUeXBlID09IDEpe1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaChub2RlLCBwYXJ0KSkgcHVzaChub2RlKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCIhXlwiOiBmdW5jdGlvbihub2RlLCBwYXJ0LCBwdXNoKXsgLy8gbGFzdCBjaGlsZFxyXG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZFxyXG4gICAgICAgIGlmIChub2RlKXtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSl7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaChub2RlLCBwYXJ0KSkgcHVzaChub2RlKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tYmluYXRvcnNbJyErJ10uY2FsbCh0aGlzLCBub2RlLCBwYXJ0LCBwdXNoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBcIiF+XCI6IGZ1bmN0aW9uKG5vZGUsIHBhcnQsIHB1c2gpeyAvLyBwcmV2aW91cyBzaWJsaW5nc1xyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSl7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmIHRoaXMubWF0Y2gobm9kZSwgcGFydCkpIHB1c2gobm9kZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5GaW5kZXIucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKGNvbnRleHQsIGV4cHJlc3Npb24sIGZvdW5kKXtcclxuXHJcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSB0aGlzLmRvY3VtZW50XHJcbiAgICBlbHNlIGlmICghY29udGV4dC5ub2RlVHlwZSAmJiBjb250ZXh0LmRvY3VtZW50KSBjb250ZXh0ID0gY29udGV4dC5kb2N1bWVudFxyXG5cclxuICAgIHZhciBleHByZXNzaW9ucyA9IHBhcnNlKGV4cHJlc3Npb24pXHJcblxyXG4gICAgLy8gbm8gZXhwcmVzc2lvbnMgd2VyZSBwYXJzZWQuIHRvZG86IGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT9cclxuICAgIGlmICghZXhwcmVzc2lvbnMgfHwgIWV4cHJlc3Npb25zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBleHByZXNzaW9uXCIpXHJcblxyXG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBbXVxyXG5cclxuICAgIHZhciB1bmlxdWVzLCBwdXNoID0gaXNBcnJheShmb3VuZCkgPyBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICBmb3VuZFtmb3VuZC5sZW5ndGhdID0gbm9kZVxyXG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgIGZvdW5kW2ZvdW5kLmxlbmd0aCsrXSA9IG5vZGVcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGV4cHJlc3Npb24gd2UgbmVlZCB0byBjaGVjayBmb3IgZHVwbGljYXRlcyB3aGVuIHdlIHB1c2ggdG8gZm91bmRcclxuICAgIC8vIHRoaXMgc2ltcGx5IHNhdmVzIHRoZSBvbGQgcHVzaCBhbmQgd3JhcHMgaXQgYXJvdW5kIGFuIHVpZCBkdXBlIGNoZWNrLlxyXG4gICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDEpe1xyXG4gICAgICAgIHVuaXF1ZXMgPSB7fVxyXG4gICAgICAgIHZhciBwbHVzaCA9IHB1c2hcclxuICAgICAgICBwdXNoID0gZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgICAgIHZhciB1aWQgPSB1bmlxdWVJRChub2RlKVxyXG4gICAgICAgICAgICBpZiAoIXVuaXF1ZXNbdWlkXSl7XHJcbiAgICAgICAgICAgICAgICB1bmlxdWVzW3VpZF0gPSB0cnVlXHJcbiAgICAgICAgICAgICAgICBwbHVzaChub2RlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdhbGtlclxyXG5cclxuICAgIHZhciBub2RlLCBub2RlcywgcGFydFxyXG5cclxuICAgIG1haW46IGZvciAodmFyIGkgPSAwOyBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaSsrXTspe1xyXG5cclxuICAgICAgICAvLyBxdWVyeVNlbGVjdG9yXHJcblxyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgZnVuY3Rpb25hbCB0ZXN0c1xyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBxdWVyeVNlbGVjdG9yQWxsIChhbmQgdGhlIGV4cHJlc3Npb24gZG9lcyBub3QgZmFpbCkgdXNlIGl0LlxyXG4gICAgICAgIGlmICghc2xpY2subm9RU0EgJiYgdGhpcy5xdWVyeVNlbGVjdG9yQWxsKXtcclxuXHJcbiAgICAgICAgICAgIG5vZGVzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKGNvbnRleHQsIGV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIGlmIChub2RlcyAhPT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMgJiYgbm9kZXMubGVuZ3RoKSBmb3IgKHZhciBqID0gMDsgbm9kZSA9IG5vZGVzW2orK107KSBpZiAobm9kZS5ub2RlTmFtZSA+ICdAJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaChub2RlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWUgbWFpblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwYXJ0IGluIHRoZSBleHByZXNzaW9uIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZWFjaCBwYXJ0IGZvciBkdXBsaWNhdGVzLlxyXG4gICAgICAgIC8vIHRvZG86IHRoaXMgbWlnaHQgYmUgdG9vIG5haXZlLiB3aGlsZSBzb2xpZCwgdGhlcmUgY2FuIGJlIGV4cHJlc3Npb24gc2VxdWVuY2VzIHRoYXQgZG8gbm90XHJcbiAgICAgICAgLy8gcHJvZHVjZSBkdXBsaWNhdGVzLiBcImJvZHkgZGl2XCIgZm9yIGluc3RhbmNlLCBjYW4gbmV2ZXIgZ2l2ZSB5b3UgZWFjaCBkaXYgbW9yZSB0aGFuIG9uY2UuXHJcbiAgICAgICAgLy8gXCJib2R5IGRpdiBhXCIgb24gdGhlIG90aGVyIGhhbmQgbWlnaHQuXHJcbiAgICAgICAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxKXtcclxuXHJcbiAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uWzBdXHJcbiAgICAgICAgICAgIGNvbWJpbmF0b3JzW3BhcnQuY29tYmluYXRvcl0uY2FsbCh0aGlzLCBjb250ZXh0LCBwYXJ0LCBwdXNoKVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNzID0gW2NvbnRleHRdLCBjLCBmLCB1LCBwID0gZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gdW5pcXVlSUQobm9kZSlcclxuICAgICAgICAgICAgICAgIGlmICghdVt1aWRdKXtcclxuICAgICAgICAgICAgICAgICAgICB1W3VpZF0gPSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgZltmLmxlbmd0aF0gPSBub2RlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGxvb3AgdGhlIGV4cHJlc3Npb24gcGFydHNcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IHBhcnQgPSBleHByZXNzaW9uW2orK107KXtcclxuICAgICAgICAgICAgICAgIGYgPSBbXTsgdSA9IHt9XHJcbiAgICAgICAgICAgICAgICAvLyBsb29wIHRoZSBjb250ZXh0c1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGMgPSBjc1trKytdOykgY29tYmluYXRvcnNbcGFydC5jb21iaW5hdG9yXS5jYWxsKHRoaXMsIGMsIHBhcnQsIHApXHJcbiAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHdhcyBmb3VuZCwgdGhlIGV4cHJlc3Npb24gZmFpbGVkLCBjb250aW51ZSB0byB0aGUgbmV4dCBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFmLmxlbmd0aCkgY29udGludWUgbWFpblxyXG4gICAgICAgICAgICAgICAgY3MgPSBmIC8vIHNldCB0aGUgY29udGV4dHMgZm9yIGZ1dHVyZSBwYXJ0cyAoaWYgYW55KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgZm91bmQgPSBmIC8vIGZpcnN0IGV4cHJlc3Npb24uIGRpcmVjdGx5IHNldCBmb3VuZC5cclxuICAgICAgICAgICAgZWxzZSBmb3IgKHZhciBsID0gMDsgbCA8IGYubGVuZ3RoOyBsKyspIHB1c2goZltsXSkgLy8gYW55IG90aGVyIGV4cHJlc3Npb24gbmVlZHMgdG8gcHVzaCB0byBmb3VuZC5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGlmICh1bmlxdWVzICYmIGZvdW5kICYmIGZvdW5kLmxlbmd0aCA+IDEpIHRoaXMuc29ydChmb3VuZClcclxuXHJcbiAgICByZXR1cm4gZm91bmRcclxuXHJcbn1cclxuXHJcbkZpbmRlci5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKG5vZGVzKXtcclxuICAgIHJldHVybiB0aGlzLnNvcnRlciA/IEFycmF5LnByb3RvdHlwZS5zb3J0LmNhbGwobm9kZXMsIHRoaXMuc29ydGVyKSA6IG5vZGVzXHJcbn1cclxuXHJcbi8vIFRPRE86IG1vc3Qgb2YgdGhlc2UgcHNldWRvIHNlbGVjdG9ycyBpbmNsdWRlIDxodG1sPiBhbmQgcXNhIGRvZXNudC4gZml4bWUuXHJcblxyXG52YXIgcHNldWRvcyA9IHtcclxuXHJcblxyXG4gICAgLy8gVE9ETzogcmV0dXJucyBkaWZmZXJlbnQgcmVzdWx0cyB0aGFuIHFzYSBlbXB0eS5cclxuXHJcbiAgICAnZW1wdHknOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiAhKHRoaXMgJiYgdGhpcy5ub2RlVHlwZSA9PT0gMSkgJiYgISh0aGlzLmlubmVyVGV4dCB8fCB0aGlzLnRleHRDb250ZW50IHx8ICcnKS5sZW5ndGhcclxuICAgIH0sXHJcblxyXG4gICAgJ25vdCc6IGZ1bmN0aW9uKGV4cHJlc3Npb24pe1xyXG4gICAgICAgIHJldHVybiAhc2xpY2subWF0Y2hlcyh0aGlzLCBleHByZXNzaW9uKVxyXG4gICAgfSxcclxuXHJcbiAgICAnY29udGFpbnMnOiBmdW5jdGlvbih0ZXh0KXtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaW5uZXJUZXh0IHx8IHRoaXMudGV4dENvbnRlbnQgfHwgJycpLmluZGV4T2YodGV4dCkgPiAtMVxyXG4gICAgfSxcclxuXHJcbiAgICAnZmlyc3QtY2hpbGQnOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpc1xyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSkgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0sXHJcblxyXG4gICAgJ2xhc3QtY2hpbGQnOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpc1xyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpKSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSByZXR1cm4gZmFsc2VcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAnb25seS1jaGlsZCc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzXHJcbiAgICAgICAgd2hpbGUgKChwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmcpKSBpZiAocHJldi5ub2RlVHlwZSA9PSAxKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzXHJcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gbmV4dC5uZXh0U2libGluZykpIGlmIChuZXh0Lm5vZGVUeXBlID09IDEpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAnZmlyc3Qtb2YtdHlwZSc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWVcclxuICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykpIGlmIChub2RlLm5vZGVOYW1lID09IG5vZGVOYW1lKSByZXR1cm4gZmFsc2VcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAnbGFzdC1vZi10eXBlJzogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZVxyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpKSBpZiAobm9kZS5ub2RlTmFtZSA9PSBub2RlTmFtZSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0sXHJcblxyXG4gICAgJ29ubHktb2YtdHlwZSc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWVcclxuICAgICAgICB3aGlsZSAoKHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZykpIGlmIChwcmV2Lm5vZGVOYW1lID09IG5vZGVOYW1lKSByZXR1cm4gZmFsc2VcclxuICAgICAgICB2YXIgbmV4dCA9IHRoaXNcclxuICAgICAgICB3aGlsZSAoKG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKSkgaWYgKG5leHQubm9kZU5hbWUgPT0gbm9kZU5hbWUpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9LFxyXG5cclxuICAgICdlbmFibGVkJzogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWRcclxuICAgIH0sXHJcblxyXG4gICAgJ2Rpc2FibGVkJzogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZFxyXG4gICAgfSxcclxuXHJcbiAgICAnY2hlY2tlZCc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZCB8fCB0aGlzLnNlbGVjdGVkXHJcbiAgICB9LFxyXG5cclxuICAgICdzZWxlY3RlZCc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRcclxuICAgIH0sXHJcblxyXG4gICAgJ2ZvY3VzJzogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50XHJcbiAgICAgICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50ID09PSB0aGlzICYmICh0aGlzLmhyZWYgfHwgdGhpcy50eXBlIHx8IHNsaWNrLmhhc0F0dHJpYnV0ZSh0aGlzLCAndGFiaW5kZXgnKSlcclxuICAgIH0sXHJcblxyXG4gICAgJ3Jvb3QnOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiAodGhpcyA9PT0gdGhpcy5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbkZpbmRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihub2RlLCBiaXQsIG5vVGFnLCBub0lkLCBub0NsYXNzKXtcclxuXHJcbiAgICAvLyBUT0RPOiBtb3JlIGZ1bmN0aW9uYWwgdGVzdHMgP1xyXG5cclxuICAgIGlmICghc2xpY2subm9RU0EgJiYgdGhpcy5tYXRjaGVzU2VsZWN0b3Ipe1xyXG4gICAgICAgIHZhciBtYXRjaGVzID0gdGhpcy5tYXRjaGVzU2VsZWN0b3Iobm9kZSwgYml0KVxyXG4gICAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSByZXR1cm4gbWF0Y2hlc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG5vcm1hbCBtYXRjaGluZ1xyXG5cclxuICAgIGlmICghbm9UYWcgJiYgYml0LnRhZyl7XHJcblxyXG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIGlmIChiaXQudGFnID09PSBcIipcIil7XHJcbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA8IFwiQFwiKSByZXR1cm4gZmFsc2VcclxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lICE9IGJpdC50YWcpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGlmICghbm9JZCAmJiBiaXQuaWQgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykgIT09IGJpdC5pZCkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgdmFyIGksIHBhcnRcclxuXHJcbiAgICBpZiAoIW5vQ2xhc3MgJiYgYml0LmNsYXNzZXMpe1xyXG5cclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUobm9kZSwgXCJjbGFzc1wiKVxyXG4gICAgICAgIGlmICghY2xhc3NOYW1lKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgZm9yIChwYXJ0IGluIGJpdC5jbGFzc2VzKSBpZiAoIVJlZ0V4cCgnKF58XFxcXHMpJyArIGJpdC5jbGFzc2VzW3BhcnRdICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKSkgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5hbWUsIHZhbHVlXHJcblxyXG4gICAgaWYgKGJpdC5hdHRyaWJ1dGVzKSBmb3IgKGkgPSAwOyBwYXJ0ID0gYml0LmF0dHJpYnV0ZXNbaSsrXTspe1xyXG5cclxuICAgICAgICB2YXIgb3BlcmF0b3IgID0gcGFydC5vcGVyYXRvcixcclxuICAgICAgICAgICAgZXNjYXBlZCAgID0gcGFydC5lc2NhcGVkVmFsdWVcclxuXHJcbiAgICAgICAgbmFtZSAgPSBwYXJ0Lm5hbWVcclxuICAgICAgICB2YWx1ZSA9IHBhcnQudmFsdWVcclxuXHJcbiAgICAgICAgaWYgKCFvcGVyYXRvcil7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKG5vZGUsIG5hbWUpKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhY3R1YWwgPSB0aGlzLmdldEF0dHJpYnV0ZShub2RlLCBuYW1lKVxyXG4gICAgICAgICAgICBpZiAoYWN0dWFsID09IG51bGwpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcil7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdePScgOiBpZiAoIVJlZ0V4cCggICAgICAnXicgKyBlc2NhcGVkICAgICAgICAgICAgKS50ZXN0KGFjdHVhbCkpIHJldHVybiBmYWxzZTsgYnJlYWtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyQ9JyA6IGlmICghUmVnRXhwKCAgICAgICAgICAgIGVzY2FwZWQgKyAnJCcgICAgICApLnRlc3QoYWN0dWFsKSkgcmV0dXJuIGZhbHNlOyBicmVha1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnfj0nIDogaWYgKCFSZWdFeHAoJyhefFxcXFxzKScgKyBlc2NhcGVkICsgJyhcXFxcc3wkKScpLnRlc3QoYWN0dWFsKSkgcmV0dXJuIGZhbHNlOyBicmVha1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnfD0nIDogaWYgKCFSZWdFeHAoICAgICAgJ14nICsgZXNjYXBlZCArICcoLXwkKScgICkudGVzdChhY3R1YWwpKSByZXR1cm4gZmFsc2U7IGJyZWFrXHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnPScgIDogaWYgKGFjdHVhbCAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTsgYnJlYWtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyo9JyA6IGlmIChhY3R1YWwuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSByZXR1cm4gZmFsc2U7IGJyZWFrXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0ICAgOiByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJpdC5wc2V1ZG9zKSBmb3IgKGkgPSAwOyBwYXJ0ID0gYml0LnBzZXVkb3NbaSsrXTspe1xyXG5cclxuICAgICAgICBuYW1lICA9IHBhcnQubmFtZVxyXG4gICAgICAgIHZhbHVlID0gcGFydC52YWx1ZVxyXG5cclxuICAgICAgICBpZiAocHNldWRvc1tuYW1lXSkgcmV0dXJuIHBzZXVkb3NbbmFtZV0uY2FsbChub2RlLCB2YWx1ZSlcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpe1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSkgIT09IHZhbHVlKSByZXR1cm4gZmFsc2VcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKG5vZGUsIG5hbWUpKSByZXR1cm4gZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlXHJcblxyXG59XHJcblxyXG5GaW5kZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbihub2RlLCBleHByZXNzaW9uKXtcclxuXHJcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBwYXJzZShleHByZXNzaW9uKVxyXG5cclxuICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvbnNbMF0ubGVuZ3RoID09PSAxKXsgLy8gc2ltcGxlc3QgbWF0Y2hcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaChub2RlLCBleHByZXNzaW9uc1swXVswXSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBtb3JlIGZ1bmN0aW9uYWwgdGVzdHMgP1xyXG5cclxuICAgIGlmICghc2xpY2subm9RU0EgJiYgdGhpcy5tYXRjaGVzU2VsZWN0b3Ipe1xyXG4gICAgICAgIHZhciBtYXRjaGVzID0gdGhpcy5tYXRjaGVzU2VsZWN0b3Iobm9kZSwgZXhwcmVzc2lvbnMpXHJcbiAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHJldHVybiBtYXRjaGVzXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5vZGVzID0gdGhpcy5zZWFyY2godGhpcy5kb2N1bWVudCwgZXhwcmVzc2lvbiwge2xlbmd0aDogMH0pXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIHJlczsgcmVzID0gbm9kZXNbaSsrXTspIGlmIChub2RlID09PSByZXMpIHJldHVybiB0cnVlXHJcbiAgICByZXR1cm4gZmFsc2VcclxuXHJcbn1cclxuXHJcbnZhciBmaW5kZXJzID0ge31cclxuXHJcbnZhciBmaW5kZXIgPSBmdW5jdGlvbihjb250ZXh0KXtcclxuICAgIHZhciBkb2MgPSBjb250ZXh0IHx8IGRvY3VtZW50XHJcbiAgICBpZiAoZG9jLm93bmVyRG9jdW1lbnQpIGRvYyA9IGRvYy5vd25lckRvY3VtZW50XHJcbiAgICBlbHNlIGlmIChkb2MuZG9jdW1lbnQpIGRvYyA9IGRvYy5kb2N1bWVudFxyXG5cclxuICAgIGlmIChkb2Mubm9kZVR5cGUgIT09IDkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGRvY3VtZW50XCIpXHJcblxyXG4gICAgdmFyIHVpZCA9IHVuaXF1ZUlEKGRvYylcclxuICAgIHJldHVybiBmaW5kZXJzW3VpZF0gfHwgKGZpbmRlcnNbdWlkXSA9IG5ldyBGaW5kZXIoZG9jKSlcclxufVxyXG5cclxuLy8gLi4uIEFQSSAuLi5cclxuXHJcbnZhciBzbGljayA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIGNvbnRleHQpe1xyXG4gICAgcmV0dXJuIHNsaWNrLnNlYXJjaChleHByZXNzaW9uLCBjb250ZXh0KVxyXG59XHJcblxyXG5zbGljay5zZWFyY2ggPSBmdW5jdGlvbihleHByZXNzaW9uLCBjb250ZXh0LCBmb3VuZCl7XHJcbiAgICByZXR1cm4gZmluZGVyKGNvbnRleHQpLnNlYXJjaChjb250ZXh0LCBleHByZXNzaW9uLCBmb3VuZClcclxufVxyXG5cclxuc2xpY2suZmluZCA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIGNvbnRleHQpe1xyXG4gICAgcmV0dXJuIGZpbmRlcihjb250ZXh0KS5zZWFyY2goY29udGV4dCwgZXhwcmVzc2lvbilbMF0gfHwgbnVsbFxyXG59XHJcblxyXG5zbGljay5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihub2RlLCBuYW1lKXtcclxuICAgIHJldHVybiBmaW5kZXIobm9kZSkuZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUpXHJcbn1cclxuXHJcbnNsaWNrLmhhc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5vZGUsIG5hbWUpe1xyXG4gICAgcmV0dXJuIGZpbmRlcihub2RlKS5oYXNBdHRyaWJ1dGUobm9kZSwgbmFtZSlcclxufVxyXG5cclxuc2xpY2suY29udGFpbnMgPSBmdW5jdGlvbihjb250ZXh0LCBub2RlKXtcclxuICAgIHJldHVybiBmaW5kZXIoY29udGV4dCkuY29udGFpbnMoY29udGV4dCwgbm9kZSlcclxufVxyXG5cclxuc2xpY2subWF0Y2hlcyA9IGZ1bmN0aW9uKG5vZGUsIGV4cHJlc3Npb24pe1xyXG4gICAgcmV0dXJuIGZpbmRlcihub2RlKS5tYXRjaGVzKG5vZGUsIGV4cHJlc3Npb24pXHJcbn1cclxuXHJcbnNsaWNrLnNvcnQgPSBmdW5jdGlvbihub2Rlcyl7XHJcbiAgICBpZiAobm9kZXMgJiYgbm9kZXMubGVuZ3RoID4gMSkgZmluZGVyKG5vZGVzWzBdKS5zb3J0KG5vZGVzKVxyXG4gICAgcmV0dXJuIG5vZGVzXHJcbn1cclxuXHJcbnNsaWNrLnBhcnNlID0gcGFyc2U7XHJcblxyXG4vLyBzbGljay5kZWJ1ZyA9IHRydWVcclxuLy8gc2xpY2subm9RU0EgID0gdHJ1ZVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzbGlja1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/slick/finder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/slick/index.js":
/*!*************************************!*\
  !*** ./node_modules/slick/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\nslick\r\n*/\r\n\r\nmodule.exports = \"document\" in global ? __webpack_require__(/*! ./finder */ \"(rsc)/./node_modules/slick/finder.js\") : { parse: __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/slick/parser.js\") }\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2xpY2svaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLEVBQWM7QUFDZDtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLHNEQUFVLE1BQU0sT0FBTyxtQkFBTyxDQUFDLHNEQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VyYWNlbC1wZW9wbGUvLi9ub2RlX21vZHVsZXMvc2xpY2svaW5kZXguanM/ZmZhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5zbGlja1xyXG4qL1widXNlIHN0cmljdFwiXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFwiZG9jdW1lbnRcIiBpbiBnbG9iYWwgPyByZXF1aXJlKFwiLi9maW5kZXJcIikgOiB7IHBhcnNlOiByZXF1aXJlKFwiLi9wYXJzZXJcIikgfVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/slick/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/slick/parser.js":
/*!**************************************!*\
  !*** ./node_modules/slick/parser.js ***!
  \**************************************/
/***/ ((module) => {

eval("/*\r\nSlick Parser\r\n - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)\r\n*/\r\n\r\n// Notable changes from Slick.Parser 1.0.x\r\n\r\n// The parser now uses 2 classes: Expressions and Expression\r\n// `new Expressions` produces an array-like object containing a list of Expression objects\r\n// - Expressions::toString() produces a cleaned up expressions string\r\n// `new Expression` produces an array-like object\r\n// - Expression::toString() produces a cleaned up expression string\r\n// The only exposed method is parse, which produces a (cached) `new Expressions` instance\r\n// parsed.raw is no longer present, use .toString()\r\n// parsed.expression is now useless, just use the indices\r\n// parsed.reverse() has been removed for now, due to its apparent uselessness\r\n// Other changes in the Expressions object:\r\n// - classNames are now unique, and save both escaped and unescaped values\r\n// - attributes now save both escaped and unescaped values\r\n// - pseudos now save both escaped and unescaped values\r\n\r\nvar escapeRe   = /([-.*+?^${}()|[\\]\\/\\\\])/g,\r\n    unescapeRe = /\\\\/g\r\n\r\nvar escape = function(string){\r\n    // XRegExp v2.0.0-beta-3\r\n    //  https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js\r\n    return (string + \"\").replace(escapeRe, '\\\\$1')\r\n}\r\n\r\nvar unescape = function(string){\r\n    return (string + \"\").replace(unescapeRe, '')\r\n}\r\n\r\nvar slickRe = RegExp(\r\n/*\r\n#!/usr/bin/env ruby\r\nputs \"\\t\\t\" + DATA.read.gsub(/\\(\\?x\\)|\\s+#.*$|\\s+|\\\\$|\\\\n/,'')\r\n__END__\r\n    \"(?x)^(?:\\\r\n      \\\\s* ( , ) \\\\s*               # Separator          \\n\\\r\n    | \\\\s* ( <combinator>+ ) \\\\s*   # Combinator         \\n\\\r\n    |      ( \\\\s+ )                 # CombinatorChildren \\n\\\r\n    |      ( <unicode>+ | \\\\* )     # Tag                \\n\\\r\n    | \\\\#  ( <unicode>+       )     # ID                 \\n\\\r\n    | \\\\.  ( <unicode>+       )     # ClassName          \\n\\\r\n    |                               # Attribute          \\n\\\r\n    \\\\[  \\\r\n        \\\\s* (<unicode1>+)  (?:  \\\r\n            \\\\s* ([*^$!~|]?=)  (?:  \\\r\n                \\\\s* (?:\\\r\n                    ([\\\"']?)(.*?)\\\\9 \\\r\n                )\\\r\n            )  \\\r\n        )?  \\\\s*  \\\r\n    \\\\](?!\\\\]) \\n\\\r\n    |   :+ ( <unicode>+ )(?:\\\r\n    \\\\( (?:\\\r\n        (?:([\\\"'])([^\\\\12]*)\\\\12)|((?:\\\\([^)]+\\\\)|[^()]*)+)\\\r\n    ) \\\\)\\\r\n    )?\\\r\n    )\"\r\n*/\r\n\"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\"\r\n    .replace(/<combinator>/, '[' + escape(\">+~`!@$%^&={}\\\\;</\") + ']')\r\n    .replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n    .replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n)\r\n\r\n// Part\r\n\r\nvar Part = function Part(combinator){\r\n    this.combinator = combinator || \" \"\r\n    this.tag = \"*\"\r\n}\r\n\r\nPart.prototype.toString = function(){\r\n\r\n    if (!this.raw){\r\n\r\n        var xpr = \"\", k, part\r\n\r\n        xpr += this.tag || \"*\"\r\n        if (this.id) xpr += \"#\" + this.id\r\n        if (this.classes) xpr += \".\" + this.classList.join(\".\")\r\n        if (this.attributes) for (k = 0; part = this.attributes[k++];){\r\n            xpr += \"[\" + part.name + (part.operator ? part.operator + '\"' + part.value + '\"' : '') + \"]\"\r\n        }\r\n        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){\r\n            xpr += \":\" + part.name\r\n            if (part.value) xpr += \"(\" + part.value + \")\"\r\n        }\r\n\r\n        this.raw = xpr\r\n\r\n    }\r\n\r\n    return this.raw\r\n}\r\n\r\n// Expression\r\n\r\nvar Expression = function Expression(){\r\n    this.length = 0\r\n}\r\n\r\nExpression.prototype.toString = function(){\r\n\r\n    if (!this.raw){\r\n\r\n        var xpr = \"\"\r\n\r\n        for (var j = 0, bit; bit = this[j++];){\r\n            if (j !== 1) xpr += \" \"\r\n            if (bit.combinator !== \" \") xpr += bit.combinator + \" \"\r\n            xpr += bit\r\n        }\r\n\r\n        this.raw = xpr\r\n\r\n    }\r\n\r\n    return this.raw\r\n}\r\n\r\nvar replacer = function(\r\n    rawMatch,\r\n\r\n    separator,\r\n    combinator,\r\n    combinatorChildren,\r\n\r\n    tagName,\r\n    id,\r\n    className,\r\n\r\n    attributeKey,\r\n    attributeOperator,\r\n    attributeQuote,\r\n    attributeValue,\r\n\r\n    pseudoMarker,\r\n    pseudoClass,\r\n    pseudoQuote,\r\n    pseudoClassQuotedValue,\r\n    pseudoClassValue\r\n){\r\n\r\n    var expression, current\r\n\r\n    if (separator || !this.length){\r\n        expression = this[this.length++] = new Expression\r\n        if (separator) return ''\r\n    }\r\n\r\n    if (!expression) expression = this[this.length - 1]\r\n\r\n    if (combinator || combinatorChildren || !expression.length){\r\n        current = expression[expression.length++] = new Part(combinator)\r\n    }\r\n\r\n    if (!current) current = expression[expression.length - 1]\r\n\r\n    if (tagName){\r\n\r\n        current.tag = unescape(tagName)\r\n\r\n    } else if (id){\r\n\r\n        current.id = unescape(id)\r\n\r\n    } else if (className){\r\n\r\n        var unescaped = unescape(className)\r\n\r\n        var classes = current.classes || (current.classes = {})\r\n        if (!classes[unescaped]){\r\n            classes[unescaped] = escape(className)\r\n            var classList = current.classList || (current.classList = [])\r\n            classList.push(unescaped)\r\n            classList.sort()\r\n        }\r\n\r\n    } else if (pseudoClass){\r\n\r\n        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue\r\n\r\n        ;(current.pseudos || (current.pseudos = [])).push({\r\n            type         : pseudoMarker.length == 1 ? 'class' : 'element',\r\n            name         : unescape(pseudoClass),\r\n            escapedName  : escape(pseudoClass),\r\n            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,\r\n            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null\r\n        })\r\n\r\n    } else if (attributeKey){\r\n\r\n        attributeValue = attributeValue ? escape(attributeValue) : null\r\n\r\n        ;(current.attributes || (current.attributes = [])).push({\r\n            operator     : attributeOperator,\r\n            name         : unescape(attributeKey),\r\n            escapedName  : escape(attributeKey),\r\n            value        : attributeValue ? unescape(attributeValue) : null,\r\n            escapedValue : attributeValue ? escape(attributeValue) : null\r\n        })\r\n\r\n    }\r\n\r\n    return ''\r\n\r\n}\r\n\r\n// Expressions\r\n\r\nvar Expressions = function Expressions(expression){\r\n    this.length = 0\r\n\r\n    var self = this\r\n\r\n    var original = expression, replaced\r\n\r\n    while (expression){\r\n        replaced = expression.replace(slickRe, function(){\r\n            return replacer.apply(self, arguments)\r\n        })\r\n        if (replaced === expression) throw new Error(original + ' is an invalid expression')\r\n        expression = replaced\r\n    }\r\n}\r\n\r\nExpressions.prototype.toString = function(){\r\n    if (!this.raw){\r\n        var expressions = []\r\n        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)\r\n        this.raw = expressions.join(\", \")\r\n    }\r\n\r\n    return this.raw\r\n}\r\n\r\nvar cache = {}\r\n\r\nvar parse = function(expression){\r\n    if (expression == null) return null\r\n    expression = ('' + expression).replace(/^\\s+|\\s+$/g, '')\r\n    return cache[expression] || (cache[expression] = new Expressions(expression))\r\n}\r\n\r\nmodule.exports = parse\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2xpY2svcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxHQUFHO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1cmFjZWwtcGVvcGxlLy4vbm9kZV9tb2R1bGVzL3NsaWNrL3BhcnNlci5qcz8zZGIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblNsaWNrIFBhcnNlclxyXG4gLSBvcmlnaW5hbGx5IGNyZWF0ZWQgYnkgdGhlIGFsbWlnaHR5IFRob21hcyBBeWxvdHQgPEBzdWJ0bGVncmFkaWVudD4gKGh0dHA6Ly9zdWJ0bGVncmFkaWVudC5jb20pXHJcbiovXCJ1c2Ugc3RyaWN0XCJcclxuXHJcbi8vIE5vdGFibGUgY2hhbmdlcyBmcm9tIFNsaWNrLlBhcnNlciAxLjAueFxyXG5cclxuLy8gVGhlIHBhcnNlciBub3cgdXNlcyAyIGNsYXNzZXM6IEV4cHJlc3Npb25zIGFuZCBFeHByZXNzaW9uXHJcbi8vIGBuZXcgRXhwcmVzc2lvbnNgIHByb2R1Y2VzIGFuIGFycmF5LWxpa2Ugb2JqZWN0IGNvbnRhaW5pbmcgYSBsaXN0IG9mIEV4cHJlc3Npb24gb2JqZWN0c1xyXG4vLyAtIEV4cHJlc3Npb25zOjp0b1N0cmluZygpIHByb2R1Y2VzIGEgY2xlYW5lZCB1cCBleHByZXNzaW9ucyBzdHJpbmdcclxuLy8gYG5ldyBFeHByZXNzaW9uYCBwcm9kdWNlcyBhbiBhcnJheS1saWtlIG9iamVjdFxyXG4vLyAtIEV4cHJlc3Npb246OnRvU3RyaW5nKCkgcHJvZHVjZXMgYSBjbGVhbmVkIHVwIGV4cHJlc3Npb24gc3RyaW5nXHJcbi8vIFRoZSBvbmx5IGV4cG9zZWQgbWV0aG9kIGlzIHBhcnNlLCB3aGljaCBwcm9kdWNlcyBhIChjYWNoZWQpIGBuZXcgRXhwcmVzc2lvbnNgIGluc3RhbmNlXHJcbi8vIHBhcnNlZC5yYXcgaXMgbm8gbG9uZ2VyIHByZXNlbnQsIHVzZSAudG9TdHJpbmcoKVxyXG4vLyBwYXJzZWQuZXhwcmVzc2lvbiBpcyBub3cgdXNlbGVzcywganVzdCB1c2UgdGhlIGluZGljZXNcclxuLy8gcGFyc2VkLnJldmVyc2UoKSBoYXMgYmVlbiByZW1vdmVkIGZvciBub3csIGR1ZSB0byBpdHMgYXBwYXJlbnQgdXNlbGVzc25lc3NcclxuLy8gT3RoZXIgY2hhbmdlcyBpbiB0aGUgRXhwcmVzc2lvbnMgb2JqZWN0OlxyXG4vLyAtIGNsYXNzTmFtZXMgYXJlIG5vdyB1bmlxdWUsIGFuZCBzYXZlIGJvdGggZXNjYXBlZCBhbmQgdW5lc2NhcGVkIHZhbHVlc1xyXG4vLyAtIGF0dHJpYnV0ZXMgbm93IHNhdmUgYm90aCBlc2NhcGVkIGFuZCB1bmVzY2FwZWQgdmFsdWVzXHJcbi8vIC0gcHNldWRvcyBub3cgc2F2ZSBib3RoIGVzY2FwZWQgYW5kIHVuZXNjYXBlZCB2YWx1ZXNcclxuXHJcbnZhciBlc2NhcGVSZSAgID0gLyhbLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdKS9nLFxyXG4gICAgdW5lc2NhcGVSZSA9IC9cXFxcL2dcclxuXHJcbnZhciBlc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpe1xyXG4gICAgLy8gWFJlZ0V4cCB2Mi4wLjAtYmV0YS0zXHJcbiAgICAvLyDCqyBodHRwczovL2dpdGh1Yi5jb20vc2xldml0aGFuL1hSZWdFeHAvYmxvYi9tYXN0ZXIvc3JjL3hyZWdleHAuanNcclxuICAgIHJldHVybiAoc3RyaW5nICsgXCJcIikucmVwbGFjZShlc2NhcGVSZSwgJ1xcXFwkMScpXHJcbn1cclxuXHJcbnZhciB1bmVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZyl7XHJcbiAgICByZXR1cm4gKHN0cmluZyArIFwiXCIpLnJlcGxhY2UodW5lc2NhcGVSZSwgJycpXHJcbn1cclxuXHJcbnZhciBzbGlja1JlID0gUmVnRXhwKFxyXG4vKlxyXG4jIS91c3IvYmluL2VudiBydWJ5XHJcbnB1dHMgXCJcXHRcXHRcIiArIERBVEEucmVhZC5nc3ViKC9cXChcXD94XFwpfFxccysjLiokfFxccyt8XFxcXCR8XFxcXG4vLCcnKVxyXG5fX0VORF9fXHJcbiAgICBcIig/eCleKD86XFxcclxuICAgICAgXFxcXHMqICggLCApIFxcXFxzKiAgICAgICAgICAgICAgICMgU2VwYXJhdG9yICAgICAgICAgIFxcblxcXHJcbiAgICB8IFxcXFxzKiAoIDxjb21iaW5hdG9yPisgKSBcXFxccyogICAjIENvbWJpbmF0b3IgICAgICAgICBcXG5cXFxyXG4gICAgfCAgICAgICggXFxcXHMrICkgICAgICAgICAgICAgICAgICMgQ29tYmluYXRvckNoaWxkcmVuIFxcblxcXHJcbiAgICB8ICAgICAgKCA8dW5pY29kZT4rIHwgXFxcXCogKSAgICAgIyBUYWcgICAgICAgICAgICAgICAgXFxuXFxcclxuICAgIHwgXFxcXCMgICggPHVuaWNvZGU+KyAgICAgICApICAgICAjIElEICAgICAgICAgICAgICAgICBcXG5cXFxyXG4gICAgfCBcXFxcLiAgKCA8dW5pY29kZT4rICAgICAgICkgICAgICMgQ2xhc3NOYW1lICAgICAgICAgIFxcblxcXHJcbiAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgQXR0cmlidXRlICAgICAgICAgIFxcblxcXHJcbiAgICBcXFxcWyAgXFxcclxuICAgICAgICBcXFxccyogKDx1bmljb2RlMT4rKSAgKD86ICBcXFxyXG4gICAgICAgICAgICBcXFxccyogKFsqXiQhfnxdPz0pICAoPzogIFxcXHJcbiAgICAgICAgICAgICAgICBcXFxccyogKD86XFxcclxuICAgICAgICAgICAgICAgICAgICAoW1xcXCInXT8pKC4qPylcXFxcOSBcXFxyXG4gICAgICAgICAgICAgICAgKVxcXHJcbiAgICAgICAgICAgICkgIFxcXHJcbiAgICAgICAgKT8gIFxcXFxzKiAgXFxcclxuICAgIFxcXFxdKD8hXFxcXF0pIFxcblxcXHJcbiAgICB8ICAgOisgKCA8dW5pY29kZT4rICkoPzpcXFxyXG4gICAgXFxcXCggKD86XFxcclxuICAgICAgICAoPzooW1xcXCInXSkoW15cXFxcMTJdKilcXFxcMTIpfCgoPzpcXFxcKFteKV0rXFxcXCl8W14oKV0qKSspXFxcclxuICAgICkgXFxcXClcXFxyXG4gICAgKT9cXFxyXG4gICAgKVwiXHJcbiovXHJcblwiXig/OlxcXFxzKigsKVxcXFxzKnxcXFxccyooPGNvbWJpbmF0b3I+KylcXFxccyp8KFxcXFxzKyl8KDx1bmljb2RlPit8XFxcXCopfFxcXFwjKDx1bmljb2RlPispfFxcXFwuKDx1bmljb2RlPispfFxcXFxbXFxcXHMqKDx1bmljb2RlMT4rKSg/OlxcXFxzKihbKl4kIX58XT89KSg/OlxcXFxzKig/OihbXFxcIiddPykoLio/KVxcXFw5KSkpP1xcXFxzKlxcXFxdKD8hXFxcXF0pfCg6KykoPHVuaWNvZGU+KykoPzpcXFxcKCg/Oig/OihbXFxcIiddKShbXlxcXFwxM10qKVxcXFwxMyl8KCg/OlxcXFwoW14pXStcXFxcKXxbXigpXSopKykpXFxcXCkpPylcIlxyXG4gICAgLnJlcGxhY2UoLzxjb21iaW5hdG9yPi8sICdbJyArIGVzY2FwZShcIj4rfmAhQCQlXiY9e31cXFxcOzwvXCIpICsgJ10nKVxyXG4gICAgLnJlcGxhY2UoLzx1bmljb2RlPi9nLCAnKD86W1xcXFx3XFxcXHUwMGExLVxcXFx1RkZGRi1dfFxcXFxcXFxcW15cXFxcczAtOWEtZl0pJylcclxuICAgIC5yZXBsYWNlKC88dW5pY29kZTE+L2csICcoPzpbOlxcXFx3XFxcXHUwMGExLVxcXFx1RkZGRi1dfFxcXFxcXFxcW15cXFxcczAtOWEtZl0pJylcclxuKVxyXG5cclxuLy8gUGFydFxyXG5cclxudmFyIFBhcnQgPSBmdW5jdGlvbiBQYXJ0KGNvbWJpbmF0b3Ipe1xyXG4gICAgdGhpcy5jb21iaW5hdG9yID0gY29tYmluYXRvciB8fCBcIiBcIlxyXG4gICAgdGhpcy50YWcgPSBcIipcIlxyXG59XHJcblxyXG5QYXJ0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgaWYgKCF0aGlzLnJhdyl7XHJcblxyXG4gICAgICAgIHZhciB4cHIgPSBcIlwiLCBrLCBwYXJ0XHJcblxyXG4gICAgICAgIHhwciArPSB0aGlzLnRhZyB8fCBcIipcIlxyXG4gICAgICAgIGlmICh0aGlzLmlkKSB4cHIgKz0gXCIjXCIgKyB0aGlzLmlkXHJcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NlcykgeHByICs9IFwiLlwiICsgdGhpcy5jbGFzc0xpc3Quam9pbihcIi5cIilcclxuICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzKSBmb3IgKGsgPSAwOyBwYXJ0ID0gdGhpcy5hdHRyaWJ1dGVzW2srK107KXtcclxuICAgICAgICAgICAgeHByICs9IFwiW1wiICsgcGFydC5uYW1lICsgKHBhcnQub3BlcmF0b3IgPyBwYXJ0Lm9wZXJhdG9yICsgJ1wiJyArIHBhcnQudmFsdWUgKyAnXCInIDogJycpICsgXCJdXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucHNldWRvcykgZm9yIChrID0gMDsgcGFydCA9IHRoaXMucHNldWRvc1trKytdOyl7XHJcbiAgICAgICAgICAgIHhwciArPSBcIjpcIiArIHBhcnQubmFtZVxyXG4gICAgICAgICAgICBpZiAocGFydC52YWx1ZSkgeHByICs9IFwiKFwiICsgcGFydC52YWx1ZSArIFwiKVwiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJhdyA9IHhwclxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yYXdcclxufVxyXG5cclxuLy8gRXhwcmVzc2lvblxyXG5cclxudmFyIEV4cHJlc3Npb24gPSBmdW5jdGlvbiBFeHByZXNzaW9uKCl7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDBcclxufVxyXG5cclxuRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xyXG5cclxuICAgIGlmICghdGhpcy5yYXcpe1xyXG5cclxuICAgICAgICB2YXIgeHByID0gXCJcIlxyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMCwgYml0OyBiaXQgPSB0aGlzW2orK107KXtcclxuICAgICAgICAgICAgaWYgKGogIT09IDEpIHhwciArPSBcIiBcIlxyXG4gICAgICAgICAgICBpZiAoYml0LmNvbWJpbmF0b3IgIT09IFwiIFwiKSB4cHIgKz0gYml0LmNvbWJpbmF0b3IgKyBcIiBcIlxyXG4gICAgICAgICAgICB4cHIgKz0gYml0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJhdyA9IHhwclxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5yYXdcclxufVxyXG5cclxudmFyIHJlcGxhY2VyID0gZnVuY3Rpb24oXHJcbiAgICByYXdNYXRjaCxcclxuXHJcbiAgICBzZXBhcmF0b3IsXHJcbiAgICBjb21iaW5hdG9yLFxyXG4gICAgY29tYmluYXRvckNoaWxkcmVuLFxyXG5cclxuICAgIHRhZ05hbWUsXHJcbiAgICBpZCxcclxuICAgIGNsYXNzTmFtZSxcclxuXHJcbiAgICBhdHRyaWJ1dGVLZXksXHJcbiAgICBhdHRyaWJ1dGVPcGVyYXRvcixcclxuICAgIGF0dHJpYnV0ZVF1b3RlLFxyXG4gICAgYXR0cmlidXRlVmFsdWUsXHJcblxyXG4gICAgcHNldWRvTWFya2VyLFxyXG4gICAgcHNldWRvQ2xhc3MsXHJcbiAgICBwc2V1ZG9RdW90ZSxcclxuICAgIHBzZXVkb0NsYXNzUXVvdGVkVmFsdWUsXHJcbiAgICBwc2V1ZG9DbGFzc1ZhbHVlXHJcbil7XHJcblxyXG4gICAgdmFyIGV4cHJlc3Npb24sIGN1cnJlbnRcclxuXHJcbiAgICBpZiAoc2VwYXJhdG9yIHx8ICF0aGlzLmxlbmd0aCl7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXNbdGhpcy5sZW5ndGgrK10gPSBuZXcgRXhwcmVzc2lvblxyXG4gICAgICAgIGlmIChzZXBhcmF0b3IpIHJldHVybiAnJ1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXhwcmVzc2lvbikgZXhwcmVzc2lvbiA9IHRoaXNbdGhpcy5sZW5ndGggLSAxXVxyXG5cclxuICAgIGlmIChjb21iaW5hdG9yIHx8IGNvbWJpbmF0b3JDaGlsZHJlbiB8fCAhZXhwcmVzc2lvbi5sZW5ndGgpe1xyXG4gICAgICAgIGN1cnJlbnQgPSBleHByZXNzaW9uW2V4cHJlc3Npb24ubGVuZ3RoKytdID0gbmV3IFBhcnQoY29tYmluYXRvcilcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWN1cnJlbnQpIGN1cnJlbnQgPSBleHByZXNzaW9uW2V4cHJlc3Npb24ubGVuZ3RoIC0gMV1cclxuXHJcbiAgICBpZiAodGFnTmFtZSl7XHJcblxyXG4gICAgICAgIGN1cnJlbnQudGFnID0gdW5lc2NhcGUodGFnTmFtZSlcclxuXHJcbiAgICB9IGVsc2UgaWYgKGlkKXtcclxuXHJcbiAgICAgICAgY3VycmVudC5pZCA9IHVuZXNjYXBlKGlkKVxyXG5cclxuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lKXtcclxuXHJcbiAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHVuZXNjYXBlKGNsYXNzTmFtZSlcclxuXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBjdXJyZW50LmNsYXNzZXMgfHwgKGN1cnJlbnQuY2xhc3NlcyA9IHt9KVxyXG4gICAgICAgIGlmICghY2xhc3Nlc1t1bmVzY2FwZWRdKXtcclxuICAgICAgICAgICAgY2xhc3Nlc1t1bmVzY2FwZWRdID0gZXNjYXBlKGNsYXNzTmFtZSlcclxuICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGN1cnJlbnQuY2xhc3NMaXN0IHx8IChjdXJyZW50LmNsYXNzTGlzdCA9IFtdKVxyXG4gICAgICAgICAgICBjbGFzc0xpc3QucHVzaCh1bmVzY2FwZWQpXHJcbiAgICAgICAgICAgIGNsYXNzTGlzdC5zb3J0KClcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmIChwc2V1ZG9DbGFzcyl7XHJcblxyXG4gICAgICAgIHBzZXVkb0NsYXNzVmFsdWUgPSBwc2V1ZG9DbGFzc1ZhbHVlIHx8IHBzZXVkb0NsYXNzUXVvdGVkVmFsdWVcclxuXHJcbiAgICAgICAgOyhjdXJyZW50LnBzZXVkb3MgfHwgKGN1cnJlbnQucHNldWRvcyA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGUgICAgICAgICA6IHBzZXVkb01hcmtlci5sZW5ndGggPT0gMSA/ICdjbGFzcycgOiAnZWxlbWVudCcsXHJcbiAgICAgICAgICAgIG5hbWUgICAgICAgICA6IHVuZXNjYXBlKHBzZXVkb0NsYXNzKSxcclxuICAgICAgICAgICAgZXNjYXBlZE5hbWUgIDogZXNjYXBlKHBzZXVkb0NsYXNzKSxcclxuICAgICAgICAgICAgdmFsdWUgICAgICAgIDogcHNldWRvQ2xhc3NWYWx1ZSA/IHVuZXNjYXBlKHBzZXVkb0NsYXNzVmFsdWUpIDogbnVsbCxcclxuICAgICAgICAgICAgZXNjYXBlZFZhbHVlIDogcHNldWRvQ2xhc3NWYWx1ZSA/IGVzY2FwZShwc2V1ZG9DbGFzc1ZhbHVlKSA6IG51bGxcclxuICAgICAgICB9KVxyXG5cclxuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlS2V5KXtcclxuXHJcbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSBhdHRyaWJ1dGVWYWx1ZSA/IGVzY2FwZShhdHRyaWJ1dGVWYWx1ZSkgOiBudWxsXHJcblxyXG4gICAgICAgIDsoY3VycmVudC5hdHRyaWJ1dGVzIHx8IChjdXJyZW50LmF0dHJpYnV0ZXMgPSBbXSkpLnB1c2goe1xyXG4gICAgICAgICAgICBvcGVyYXRvciAgICAgOiBhdHRyaWJ1dGVPcGVyYXRvcixcclxuICAgICAgICAgICAgbmFtZSAgICAgICAgIDogdW5lc2NhcGUoYXR0cmlidXRlS2V5KSxcclxuICAgICAgICAgICAgZXNjYXBlZE5hbWUgIDogZXNjYXBlKGF0dHJpYnV0ZUtleSksXHJcbiAgICAgICAgICAgIHZhbHVlICAgICAgICA6IGF0dHJpYnV0ZVZhbHVlID8gdW5lc2NhcGUoYXR0cmlidXRlVmFsdWUpIDogbnVsbCxcclxuICAgICAgICAgICAgZXNjYXBlZFZhbHVlIDogYXR0cmlidXRlVmFsdWUgPyBlc2NhcGUoYXR0cmlidXRlVmFsdWUpIDogbnVsbFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnJ1xyXG5cclxufVxyXG5cclxuLy8gRXhwcmVzc2lvbnNcclxuXHJcbnZhciBFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIEV4cHJlc3Npb25zKGV4cHJlc3Npb24pe1xyXG4gICAgdGhpcy5sZW5ndGggPSAwXHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzXHJcblxyXG4gICAgdmFyIG9yaWdpbmFsID0gZXhwcmVzc2lvbiwgcmVwbGFjZWRcclxuXHJcbiAgICB3aGlsZSAoZXhwcmVzc2lvbil7XHJcbiAgICAgICAgcmVwbGFjZWQgPSBleHByZXNzaW9uLnJlcGxhY2Uoc2xpY2tSZSwgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcclxuICAgICAgICB9KVxyXG4gICAgICAgIGlmIChyZXBsYWNlZCA9PT0gZXhwcmVzc2lvbikgdGhyb3cgbmV3IEVycm9yKG9yaWdpbmFsICsgJyBpcyBhbiBpbnZhbGlkIGV4cHJlc3Npb24nKVxyXG4gICAgICAgIGV4cHJlc3Npb24gPSByZXBsYWNlZFxyXG4gICAgfVxyXG59XHJcblxyXG5FeHByZXNzaW9ucy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYgKCF0aGlzLnJhdyl7XHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW11cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZXhwcmVzc2lvbjsgZXhwcmVzc2lvbiA9IHRoaXNbaSsrXTspIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbilcclxuICAgICAgICB0aGlzLnJhdyA9IGV4cHJlc3Npb25zLmpvaW4oXCIsIFwiKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJhd1xyXG59XHJcblxyXG52YXIgY2FjaGUgPSB7fVxyXG5cclxudmFyIHBhcnNlID0gZnVuY3Rpb24oZXhwcmVzc2lvbil7XHJcbiAgICBpZiAoZXhwcmVzc2lvbiA9PSBudWxsKSByZXR1cm4gbnVsbFxyXG4gICAgZXhwcmVzc2lvbiA9ICgnJyArIGV4cHJlc3Npb24pLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxyXG4gICAgcmV0dXJuIGNhY2hlW2V4cHJlc3Npb25dIHx8IChjYWNoZVtleHByZXNzaW9uXSA9IG5ldyBFeHByZXNzaW9ucyhleHByZXNzaW9uKSlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/slick/parser.js\n");

/***/ })

};
;